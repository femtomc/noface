{"id":"noface-0px","title":"Research: Design effect system for manifest capabilities","description":"## Summary\n\nThe manifest system (state.zig:Manifest) implements capability-based access control with three levels: primary_files (exclusive write), read_files (shared read), forbidden_files (deny). This maps directly to **effect systems** and **capability-based security** from PL theory.\n\nDesign a formal model for manifest capabilities that enables:\n- Static reasoning about file access patterns\n- Composition of manifests when issues depend on each other\n- Runtime enforcement with clear semantics\n\n## Background: Effect Systems \u0026 Capabilities\n\n**Effect systems** track computational effects (I/O, state, exceptions) in types:\n```\nwriteFile : FilePath → Content → Eff[FileWrite] ()\nreadFile : FilePath → Eff[FileRead] Content\n```\n\n**Capability-based security** (Dennis \u0026 Van Horn, 1966) provides access via unforgeable tokens:\n```\ntype WriteCapability\u003cfile\u003e  -- Exclusive, linear\ntype ReadCapability\u003cfile\u003e   -- Shareable\n```\n\nKey insight: Manifest = capability set for an issue's execution context.\n\n## Current Implementation Analysis\n\n```zig\npub const Manifest = struct {\n    primary_files: []const []const u8,   // WriteCapability\n    read_files: []const []const u8,      // ReadCapability  \n    forbidden_files: []const []const u8, // Anti-capability\n};\n```\n\nCurrent enforcement is **post-hoc**: run agent, check git diff, rollback violations.\n\nDesired enforcement is **preventive**: intercept file operations, reject violations immediately.\n\n## Design Questions\n\n1. **Capability composition**: If issue A depends on issue B, should A inherit B's read capabilities?\n\n2. **Dynamic expansion**: NEED_FILE signal requests new capabilities mid-execution. What are the rules?\n   - Can you request write access to a file another issue holds read-only?\n   - What happens to in-flight operations during capability negotiation?\n\n3. **Linearity**: Write capabilities are currently single-holder. Should we support:\n   - Capability transfer (A finishes, passes write cap to B)?\n   - Capability borrowing (A lends to B for specific operation)?\n\n4. **Granularity**: File-level vs function-level capabilities. Trade-offs:\n   - File: Simple, no parsing required\n   - Function: More parallelism, requires AST analysis\n\n## Deliverables\n\n1. **Capability model document** in wiki/vault/design/capability-model.md\n   - Formal definitions (effect signatures)\n   - Composition rules\n   - Runtime semantics\n\n2. **Integration analysis** with existing systems\n   - Manifest struct changes needed\n   - Lock table interaction\n   - Tool interception points (Claude's Edit/Write tools)\n\n3. **Example scenarios** with expected behavior\n   - Two issues reading same file (should work)\n   - Issue trying to write to locked file (should fail immediately)\n   - Dynamic expansion request (NEED_FILE flow)\n\n## References\n\n- Dennis, J. \u0026 Van Horn, E. (1966). \"Programming Semantics for Multiprogrammed Computations\" - capability systems origin\n- Miller, M. (2006). \"Robust Composition: Towards a Unified Approach to Access Control and Concurrency Control\" - object capabilities\n- Lucassen, J. \u0026 Gifford, D. (1988). \"Polymorphic Effect Systems\" - effect systems origin\n- Koka language: https://koka-lang.github.io/ - practical effect system\n- wiki/vault/design/manifests.md - existing design doc\n\n## Files to Create/Modify\n\n- wiki/vault/design/capability-model.md (new)","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-10T15:37:56.941577-08:00","updated_at":"2025-12-10T21:35:51.803174-08:00","closed_at":"2025-12-10T21:35:51.803174-08:00","labels":["pl-foundations","research"]}
{"id":"noface-0vv","title":"Fix GitHub issue sync shell quoting errors","description":"The createGitHubIssue function in github.zig:305 builds a shell command with:\n```zig\n\"gh issue create --title \\\"{s}\\\" --label \\\"{s}\\\" --body \\\"$(cat \u003c\u003c'BEADS_EOF'\\n{s}\\nBEADS_EOF\\n)\\\"\"\n```\n\nThis causes shell parsing errors when issue titles or bodies contain special characters:\n```\n/bin/sh: -c: line 15: unexpected EOF while looking for matching \\`'\n/bin/sh: -c: line 26: syntax error: unexpected end of file\n```\n\nFailing issues include: noface-bw7, noface-3m7, noface-st2, noface-4h2, noface-zdk\n\nRoot causes:\n- Unescaped double quotes in title break the double-quoted string\n- Body content containing BEADS_EOF on its own line terminates heredoc early\n- Body containing backticks or $() causing expansion issues\n\nFix options:\n1. Use --body-file with a temp file instead of inline body\n2. Properly escape shell metacharacters before interpolation\n3. Use gh api directly with JSON payload instead of shell command","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-10T14:17:58.709372-08:00","updated_at":"2025-12-10T14:51:57.590479-08:00","closed_at":"2025-12-10T14:51:57.590479-08:00"}
{"id":"noface-0w3","title":"Orchestrator-managed review workflow with session resume","description":"Currently workers manually invoke `codex review --uncommitted` as a subprocess inside their Claude session (worker_pool.zig:385). This has several problems:\n\n## Current Problems\n\n1. **Nested processes**: Codex runs as subprocess of Claude subprocess - hard to monitor/manage\n2. **No orchestrator visibility**: Orchestrator doesn't know when workers are in review phase\n3. **Resource waste**: Claude session stays active during review (burning context/memory)\n4. **No session resume**: Workers don't use Claude's `--resume` capability - each restart rebuilds context\n5. **Review results lost**: Codex output goes to Claude's stdin, not captured for debugging/tracing\n\n## Proposed Architecture\n\n### New Signal\nWorker outputs `READY_FOR_REVIEW` when implementation is complete and ready for review.\n\n### Orchestrator Flow\n1. Detect `READY_FOR_REVIEW` signal (similar to `BLOCKED_BY_FILE` detection)\n2. Extract Claude's session_id from stream-json output\n3. Gracefully terminate worker process (or send pause signal)\n4. Store worker state: `{ issue_id, claude_session_id, status: awaiting_review }`\n5. Spawn Codex reviewer: `codex review --uncommitted`\n6. Capture review output\n7. Store review in beads: `bd comment \u003cissue_id\u003e \"Review feedback: ...\"`\n8. Resume worker: `claude --resume \u003csession_id\u003e -p \"Review feedback: \u003ccontent\u003e\"`\n\n### Benefits\n- **Orchestrator control**: Can limit concurrent reviews, prioritize by issue priority\n- **Resource efficiency**: Claude sessions paused during review\n- **Traceability**: Review feedback stored in beads issue history\n- **Session continuity**: Workers resume with full context via `--resume`\n- **Observability**: Orchestrator logs show review phase clearly\n\n## Implementation Notes\n\n1. Claude's stream-json includes `session_id` in output - need to extract and store\n2. May need new WorkerState: `.awaiting_review`\n3. Consider: should review failures allow worker retry, or escalate to human?\n4. The `--session-id \u003cuuid\u003e` flag can pre-specify session ID for easier tracking\n\n## Files to Modify\n\n- `src/worker_pool.zig`: Add READY_FOR_REVIEW detection, session extraction, review spawning\n- `src/state.zig`: Add `awaiting_review` status, store claude_session_id per worker\n- `src/streaming.zig`: Extract session_id from Claude's output\n- Worker prompt: Replace manual codex call with READY_FOR_REVIEW signal","status":"open","priority":1,"issue_type":"feature","created_at":"2025-12-10T14:35:45.302824-08:00","updated_at":"2025-12-10T14:35:45.302824-08:00","comments":[{"id":32,"issue_id":"noface-0w3","author":"femtomc","text":"Design decision: Review results stored in beads, not injected directly\n\nPer discussion, prioritize saving state to readable files (beads issues) over complex in-memory state management.\n\n## Revised Flow\n\n1. Worker signals `READY_FOR_REVIEW`\n2. Orchestrator terminates worker, saves `claude_session_id`\n3. Orchestrator runs `codex review --uncommitted`\n4. Review output stored: `bd comment \u003cissue_id\u003e \"## Review Feedback\\n\u003coutput\u003e\"`\n5. Resume worker: `claude --resume \u003csession_id\u003e -p \"Review feedback has been added to the issue. Run: bd comments \u003cissue_id\u003e\"`\n6. Worker reads feedback from beads, addresses it\n\n## Benefits of file-based state\n\n- **Debuggable**: Can inspect `bd comments \u003cissue\u003e` to see review history\n- **Recoverable**: If orchestrator crashes, review feedback persists in beads\n- **Transparent**: Human can see exactly what feedback worker received\n- **Auditable**: Full history of review cycles preserved\n- **Simple**: No complex in-memory state serialization needed\n\n## Implementation simplification\n\nThe orchestrator only needs to track:\n- `claude_session_id`: For resuming (could even store this in beads issue metadata)\n- `status: awaiting_review`: Simple enum state\n\nAll review content lives in beads - the source of truth.","created_at":"2025-12-10T22:36:50Z"},{"id":33,"issue_id":"noface-0w3","author":"femtomc","text":"Issue: Review scope with parallel workers\n\n`codex review --uncommitted` reviews ALL uncommitted changes, but with parallel workers we need to scope review to only the requesting worker's files.\n\n## Options\n\n### 1. Pipe specific diff to codex\n```bash\ngit diff -- src/foo.zig src/bar.zig | codex review -\n```\nUse manifest's `primary_files` to know which files the worker owns.\n\n### 2. Temporary staging\n```bash\ngit stash --keep-index  # stash unstaged\ngit add \u003cworker_files\u003e  # stage only worker's files\ncodex review --uncommitted\ngit reset HEAD          # unstage\ngit stash pop           # restore others' changes\n```\nRisky with parallel git operations.\n\n### 3. Worker-specific branch (cleaner)\nEach worker works on a branch: `noface/\u003cissue_id\u003e`\n```bash\ncodex review --base main  # reviews only that branch's changes\n```\nNatural isolation, but requires branch management.\n\n### 4. Pass files via prompt\n```bash\ncodex review --uncommitted \"Only review changes in: src/foo.zig, src/bar.zig\"\n```\nRelies on codex respecting the instruction.\n\n## Recommendation\n\nOption 3 (worker-specific branches) is cleanest:\n- Natural git isolation\n- `--base main` scopes review correctly  \n- Merge conflicts handled explicitly\n- Each worker's changes are traceable\n\nThis aligns with the manifest system - each issue/worker owns specific files on their branch.","created_at":"2025-12-10T22:37:54Z"},{"id":34,"issue_id":"noface-0w3","author":"femtomc","text":"Correction: Workers share single worktree\n\nAll workers operate in the same repo directory on the same branch. Branches/worktrees are too heavyweight.\n\n## Simplified approach: Manifest-scoped diff\n\nThe manifest already defines which files each worker owns. Use that to scope the review:\n\n```bash\n# Orchestrator knows worker's manifest\nfiles=\"src/foo.zig src/bar.zig\"\n\n# Pipe only those files' diff to codex\ngit diff -- $files | codex review -\n```\n\nOr for uncommitted + untracked (matching --uncommitted behavior):\n```bash\ngit diff -- $files \u003e /tmp/review-input.diff\ngit diff --cached -- $files \u003e\u003e /tmp/review-input.diff\ngit ls-files --others --exclude-standard -- $files \u003e\u003e /tmp/review-input.diff\ncodex review - \u003c /tmp/review-input.diff\n```\n\n## Implementation\n\n1. When worker signals READY_FOR_REVIEW, orchestrator looks up manifest\n2. Builds file list from `manifest.primary_files`\n3. Generates scoped diff\n4. Passes to codex via stdin\n\nThis keeps the single-worktree model and uses the manifest as the source of truth for ownership.","created_at":"2025-12-10T22:39:04Z"},{"id":44,"issue_id":"noface-0w3","author":"femtomc","text":"MANIFEST: primary=[src/worker_pool.zig,src/state.zig,src/streaming.zig,src/loop.zig] read=[src/config.zig] forbidden=[]","created_at":"2025-12-10T23:54:23Z"},{"id":53,"issue_id":"noface-0w3","author":"femtomc","text":"MANIFEST: primary=[src/worker_pool.zig,src/state.zig,src/streaming.zig,src/process.zig] read=[src/loop.zig,src/config.zig,src/transcript.zig] forbidden=[]","created_at":"2025-12-11T00:18:20Z"},{"id":66,"issue_id":"noface-0w3","author":"femtomc","text":"MANIFEST: primary=[src/core/worker_pool.zig,src/util/streaming.zig,src/core/state.zig,src/core/prompts.zig,src/core/loop.zig] read=[src/core/config.zig] forbidden=[web/]","created_at":"2025-12-11T04:37:45Z"}]}
{"id":"noface-1v7","title":"Replace batch-based scheduling with greedy dependency+lock scheduler","description":"The current batch-based scheduling architecture is redundant and causes idle workers.\n\n## Current Architecture (problematic)\n\n1. `generateBatchesFromManifests()` pre-groups ready issues by manifest conflicts\n2. `executeBatch()` blocks until ALL issues in current batch complete\n3. Workers only get assigned issues from current batch\n4. Result: idle workers waiting for batch completion even when non-conflicting work exists\n\n## Why Batches Are Redundant\n\nThe batch pre-grouping does the same conflict check that happens at runtime:\n\n**Planning time (generateBatchesFromManifests, loop.zig:1148):**\n```zig\nif (state.issuesConflict(issue_id, batch_issue_id)) {\n    conflicts = true;\n```\n\n**Execution time (worker_pool.zig:213):**\n```zig\nconst locks_acquired = self.state.tryAcquireLocks(issue_id, manifest, worker_id);\nif (!locks_acquired) continue;  // Skip conflicting issue\n```\n\nThe lock system already prevents conflicts. Batches just add artificial serialization.\n\n## Proposed Architecture\n\nReplace batch execution with a simple greedy scheduler:\n\n```\nwhile has_ready_work:\n    ready_issues = \\`bd ready\\`  # dependency-satisfied issues\n    \n    for each idle_worker:\n        for each ready_issue not already in_progress:\n            if tryAcquireLocks(issue):\n                assign(worker, issue)\n                break\n    \n    poll_running_workers()\n    handle_completions()  # releases locks, may unblock new issues\n    sleep(poll_interval)\n```\n\n## Benefits\n\n- **Maximum parallelism**: Workers never idle when non-conflicting work exists\n- **Simpler code**: Remove Batch struct, generateBatchesFromManifests, batch iteration logic\n- **Same correctness**: Dependencies enforced by \\`bd ready\\`, conflicts by lock acquisition\n- **Dynamic adaptation**: New ready issues (from completed dependencies) picked up immediately\n\n## Files to Modify\n\n- `src/state.zig`: Remove Batch struct, pending_batches, batch-related methods\n- `src/worker_pool.zig`: Replace executeBatch() with runSchedulerLoop()\n- `src/loop.zig`: Remove generateBatchesFromManifests(), simplify main loop","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-12-10T14:29:26.214697-08:00","updated_at":"2025-12-10T20:51:47.173285-08:00","closed_at":"2025-12-10T20:51:47.173285-08:00","comments":[{"id":43,"issue_id":"noface-1v7","author":"femtomc","text":"MANIFEST: primary=[src/worker_pool.zig,src/state.zig,src/loop.zig] read=[src/config.zig] forbidden=[]","created_at":"2025-12-10T23:54:19Z"},{"id":52,"issue_id":"noface-1v7","author":"femtomc","text":"MANIFEST: primary=[src/loop.zig,src/state.zig,src/worker_pool.zig] read=[src/config.zig,src/process.zig] forbidden=[]","created_at":"2025-12-11T00:18:14Z"},{"id":65,"issue_id":"noface-1v7","author":"femtomc","text":"MANIFEST: primary=[src/core/worker_pool.zig,src/core/state.zig,src/core/loop.zig,src/core/config.zig,src/core/scheduler.zig] read=[] forbidden=[web/]","created_at":"2025-12-11T04:37:41Z"}]}
{"id":"noface-264","title":"Research: Design a technical writing agent for documentation","description":"## Problem\n\nCurrent LLM agents (Claude, Codex) are poor technical writers:\n- Verbose, redundant explanations\n- Marketing-speak instead of precision\n- Lose sight of reader's actual context/knowledge level\n- Don't understand what information is *load-bearing* vs filler\n- Poor at maintaining consistency across a doc corpus\n\n## Research Questions\n\n1. **What makes technical writing good?**\n   - Minimal words, maximal information density\n   - Correct mental model transfer\n   - Examples that illuminate, not just fill space\n   - Knowing what to omit\n\n2. **Why do LLMs fail at this?**\n   - Trained on internet text (lots of bad writing)\n   - Optimized for helpfulness → verbosity\n   - No model of reader's state/knowledge\n   - No feedback loop on comprehension\n\n3. **Possible approaches to explore:**\n   - **Critic-writer loop**: Writer drafts, critic ruthlessly cuts/challenges\n   - **Reader simulation**: Model what reader knows, what they need\n   - **Diff-based docs**: Only document what changed, reference existing docs\n   - **Example-first**: Generate examples, then minimal prose around them\n   - **Structured templates**: Force specific formats (API ref, tutorial, concept)\n   - **Human-in-the-loop gates**: Flag uncertain sections for human review\n\n4. **Integration with noface:**\n   - When should doc agent run? (after feature complete? after review?)\n   - What triggers doc updates? (file changes? new public APIs?)\n   - How to scope: which files need docs vs which are internal?\n   - Where do docs live? (inline, separate markdown, wiki?)\n\n## Desired Output\n\nA design proposal for a documentation agent that:\n- Produces concise, accurate technical docs\n- Knows when docs are needed vs unnecessary\n- Maintains consistency with existing documentation\n- Can be integrated into noface orchestration loop\n\n## References to Research\n\n- Anthropic's writing guidelines (if public)\n- Technical writing style guides (Google, Microsoft)\n- Academic work on LLM editing/revision\n- Existing doc generation tools (what works, what doesn't)","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-10T14:54:17.16437-08:00","updated_at":"2025-12-10T15:16:06.788016-08:00","closed_at":"2025-12-10T15:16:06.788016-08:00","comments":[{"id":35,"issue_id":"noface-264","author":"femtomc","text":"Research complete. Artifacts created:\n\n**Wiki Documents:**\n- `wiki/vault/research/technical-writing-agent.md` - Full research summary\n- `wiki/vault/design/doc-agent.md` - Design document\n\n**Implementation Issues (P3):**\n- noface-ljr: Scope detection from git diffs\n- noface-b71: Template-driven writer\n- noface-dc2: Critic agent for ruthless editing  \n- noface-ewy: Verifier for factual accuracy\n- noface-edc: Full pipeline orchestration (depends on all above)\n\n**Dependency Graph:**\n```\nnoface-edc (Full Pipeline)\n    ├── noface-ljr (Scope)\n    ├── noface-b71 (Writer)\n    │       └── noface-dc2 (Critic) [depends on Writer]\n    └── noface-ewy (Verifier)\n```","created_at":"2025-12-10T23:15:58Z"}]}
{"id":"noface-2d6","title":"Refactor: Extract prompt builders from loop.zig into prompts.zig","description":"## Summary\n\nloop.zig contains ~500 lines of prompt building logic that should be extracted into a dedicated module. This includes:\n- buildImplementationPrompt() (lines ~2089-2210)\n- buildPlannerPrompt() (lines ~740-892)\n- buildQualityPrompt() (lines ~920-1000, estimated)\n- buildStricterPrompt() (for manifest violation retries)\n- buildWorkerPrompt() in worker_pool.zig (lines ~318-428)\n\nThese are pure functions that take context and return prompt strings - ideal for extraction.\n\n## Current Problems\n\n1. **loop.zig bloat**: Prompt templates are large string literals mixed with logic\n2. **Duplication**: Worker prompt in worker_pool.zig duplicates patterns from loop.zig\n3. **Hard to test**: Prompts embedded in orchestration logic can't be unit tested\n4. **Hard to customize**: Users can't easily override prompt templates\n\n## Proposed Module: src/prompts.zig\n\n```zig\n//! Prompt templates for agent sessions.\n//!\n//! Centralizes all prompt construction to enable:\n//! - Easy customization via prompt_templates config\n//! - Unit testing of prompt generation\n//! - Consistent prompt patterns across passes\n\npub const PromptBuilder = struct {\n    allocator: std.mem.Allocator,\n    config: PromptConfig,\n\n    pub fn buildImplementationPrompt(self: *PromptBuilder, ctx: ImplementationContext) ![]const u8 { ... }\n    pub fn buildPlannerPrompt(self: *PromptBuilder, ctx: PlannerContext) ![]const u8 { ... }\n    pub fn buildQualityPrompt(self: *PromptBuilder, ctx: QualityContext) ![]const u8 { ... }\n    pub fn buildWorkerPrompt(self: *PromptBuilder, ctx: WorkerContext) ![]const u8 { ... }\n};\n\npub const ImplementationContext = struct {\n    issue_id: []const u8,\n    project_name: []const u8,\n    code_refs: []const CodeRef,\n    design_context: []const u8,\n    manifest: ?Manifest,\n};\n// ... etc\n```\n\n## Benefits\n\n1. **Testable**: Unit test prompt generation with mock contexts\n2. **Customizable**: Config can specify template overrides per prompt type\n3. **Maintainable**: Prompt changes don't require touching orchestration logic\n4. **Consistent**: Single source of truth for prompt patterns\n\n## Files to Modify\n\n- src/prompts.zig (new)\n- src/loop.zig (extract prompt building, import from prompts.zig)\n- src/worker_pool.zig (use prompts.zig for worker prompts)\n- src/config.zig (add prompt template config fields)","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-10T15:43:47.4779-08:00","updated_at":"2025-12-10T15:43:47.4779-08:00","labels":["modularization","refactor"],"comments":[{"id":45,"issue_id":"noface-2d6","author":"femtomc","text":"MANIFEST: primary=[src/prompts.zig,src/loop.zig,src/worker_pool.zig,src/config.zig] read=[] forbidden=[]","created_at":"2025-12-10T23:54:26Z"},{"id":54,"issue_id":"noface-2d6","author":"femtomc","text":"MANIFEST: primary=[src/prompts.zig,src/loop.zig,src/worker_pool.zig,src/config.zig,src/root.zig] read=[src/monowiki.zig,src/streaming.zig] forbidden=[]","created_at":"2025-12-11T00:18:24Z"},{"id":67,"issue_id":"noface-2d6","author":"femtomc","text":"MANIFEST: primary=[src/core/prompts.zig,src/core/loop.zig,src/core/worker_pool.zig,src/core/config.zig] read=[src/core/state.zig] forbidden=[web/]","created_at":"2025-12-11T04:37:50Z"}]}
{"id":"noface-2qg","title":"Add BLOCKED status with human escalation summary","description":"Define clear escalation threshold with actionable summary.\n\nAfter N consecutive failed attempts (e.g., 3) or severe failure type:\n1. Mark issue as BLOCKED\n2. Post a summary:\n   - What was tried\n   - Errors encountered\n   - What the agent thinks is unclear (if any)\n3. Pause automation until human:\n   - Adds context\n   - Edits the issue, or\n   - Manually unblocks / retries\n\nReference: [[failure-recovery]] design doc","status":"open","priority":2,"issue_type":"feature","created_at":"2025-12-10T12:03:49.636111-08:00","updated_at":"2025-12-10T12:03:49.636111-08:00","labels":["failure-recovery","human-in-loop"]}
{"id":"noface-2ua","title":"Research: Formalize worker-orchestrator protocol with session types","description":"## Summary\n\nThe worker-orchestrator communication in noface uses an implicit protocol with several message types (BLOCKED_BY_FILE, ISSUE_COMPLETE, READY_FOR_REVIEW, NEED_FILE) exchanged over stdout. This protocol is currently encoded ad-hoc in signal detection logic scattered across worker_pool.zig.\n\nFormalize this protocol using **session types** - a type discipline for communication protocols that guarantees:\n- All message patterns are explicitly declared\n- Both parties (worker/orchestrator) handle all possible messages\n- Protocol evolution can be checked for compatibility\n\n## Background: Session Types\n\nSession types originated in process calculi (Honda, 1993) and have been applied to practical languages:\n- **Scribble** (Honda et al.): Protocol description language used at Red Hat\n- **Session Types for Rust** (Kokke \u0026 Dardha, 2021): Compile-time protocol verification\n- **Propositions as Sessions** (Wadler, 2012): Logical foundations via Curry-Howard\n\nKey paper: \"Session Types: An Introduction\" (Vasconcelos, 2009) - provides accessible overview.\n\n## Current Implicit Protocol\n\n```\nWorker → Orchestrator:\n  | BLOCKED_BY_FILE: \u003cpath\u003e     -- Request wait on file lock\n  | ISSUE_COMPLETE              -- Signal successful completion\n  | READY_FOR_REVIEW            -- Request review phase (proposed in noface-0w3)\n  | NEED_FILE: \u003cpath\u003e           -- Request manifest expansion (from manifests.md TODO)\n  | \u003cstreaming output\u003e          -- Progress indication\n\nOrchestrator → Worker:\n  | (process termination)       -- Kill signal\n  | (resume with new prompt)    -- After review or unblock\n```\n\n## Deliverables\n\n1. **Protocol specification document** in wiki/vault/design/worker-protocol.md\n   - Formal session type notation\n   - Message grammar (EBNF or similar)\n   - State machine diagram\n   - Error handling semantics\n\n2. **Compatibility analysis** with existing code\n   - Map current signal detection to protocol states\n   - Identify missing cases (unhandled messages)\n   - Document implicit assumptions\n\n3. **Extension points** for future messages\n   - CHECKPOINT: \u003cstate\u003e for crash recovery\n   - PROGRESS: \u003cpercentage\u003e for UI feedback\n   - DELEGATE: \u003cissue_id\u003e for work splitting\n\n## References\n\n- Honda, K. (1993). \"Types for Dyadic Interaction\"\n- Wadler, P. (2012). \"Propositions as Sessions\" - https://homepages.inf.ed.ac.uk/wadler/papers/propositions-as-sessions/propositions-as-sessions.pdf\n- Kokke, W. \u0026 Dardha, O. (2021). \"Deadlock-Free Session Types in Rust\"\n- Vasconcelos, V. (2009). \"Session Types: An Introduction\" - tutorial paper\n- Scribble Project: https://www.scribble.org/\n\n## Files to Create/Modify\n\n- wiki/vault/design/worker-protocol.md (new)\n- wiki/vault/research/session-types.md (new, optional deep-dive)","status":"open","priority":2,"issue_type":"feature","created_at":"2025-12-10T15:37:31.021187-08:00","updated_at":"2025-12-10T15:37:31.021187-08:00","labels":["pl-foundations","research"]}
{"id":"noface-31u","title":"Implement: Formal signal grammar with generated parser","description":"## Summary\n\nWorker-orchestrator signals (BLOCKED_BY_FILE, ISSUE_COMPLETE, etc.) are parsed with ad-hoc string searches in worker_pool.zig. This has caused bugs:\n- noface-c3d: JSON garbage extracted instead of file path\n- Signals inside JSON strings incorrectly matched\n\nDefine a **formal grammar** for signals and generate a robust parser.\n\n## Background: Parser Combinators \u0026 Grammars\n\nFormal grammars provide:\n- Unambiguous specification of valid inputs\n- Foundation for parser generation\n- Basis for error messages\n\nParser combinator libraries (Parsec, nom, mpc) allow compositional parser construction from grammar.\n\n## Current Parsing (Problematic)\n\n```zig\n// worker_pool.zig:1049-1073\nconst BLOCKED_SIGNAL = \"BLOCKED_BY_FILE:\";\n\nfn checkForBlockedSignal(self: *WorkerProcess) void {\n    if (std.mem.indexOf(u8, output, BLOCKED_SIGNAL)) |pos| {\n        // Extract file path... but may include JSON garbage\n    }\n}\n```\n\nProblem: Searches raw output buffer which contains JSON like:\n```json\n{\"content\":\"BLOCKED_BY_FILE: src/foo.zig\"}],\"stop_reason\":null\n```\n\n## Proposed Grammar (EBNF)\n\n```ebnf\nsignal      = blocked_signal | complete_signal | review_signal | need_signal ;\n\nblocked_signal  = \"BLOCKED_BY_FILE:\" ws file_path eol ;\ncomplete_signal = \"ISSUE_COMPLETE\" eol ;\nreview_signal   = \"READY_FOR_REVIEW\" eol ;\nneed_signal     = \"NEED_FILE:\" ws file_path eol \n                | \"NEED_DOC:\" ws doc_path eol ;\n\nfile_path   = path_char+ ;\ndoc_path    = path_char+ ;\npath_char   = letter | digit | \"/\" | \".\" | \"_\" | \"-\" ;\nws          = (\" \" | \"\\t\")* ;\neol         = \"\\n\" | \"\\r\\n\" | EOF ;\n```\n\n## Design Decisions\n\n1. **Where to parse**: Parse extracted text content from JSON events, not raw buffer\n   - streaming.zig already extracts text from content_block_delta\n   - Parse signals from extracted text only\n\n2. **Signal boundary**: Signals must be on their own line\n   - Prevents matching signals inside prose\n   - `BLOCKED_BY_FILE: src/foo.zig` is valid\n   - `I output BLOCKED_BY_FILE: x because...` is NOT a signal\n\n3. **Parser implementation**: Simple hand-written parser or Zig comptime combinator\n   - Full combinator library is overkill for this grammar\n   - Comptime string matching with structured output\n\n## Deliverables\n\n1. **Grammar specification** in wiki/vault/design/signal-grammar.md\n   - EBNF definition\n   - Examples of valid/invalid signals\n   - Extension rules for new signals\n\n2. **Signal parser module** src/signals_parser.zig\n   - Structured Signal union type\n   - Parse function: []const u8 → ?Signal\n   - Clear error messages for malformed signals\n\n3. **Integration** with worker_pool.zig\n   - Replace indexOf-based detection\n   - Parse from JSON-extracted text content\n\n4. **Tests** for all signal types and edge cases\n\n## References\n\n- Hutton, G. (1992). \"Higher-Order Functions for Parsing\"\n- Leijen, D. \u0026 Meijer, E. (2001). \"Parsec: A practical parser library\"\n- mpc: https://github.com/orangeduck/mpc - parser combinator in C\n\n## Files to Create/Modify\n\n- src/signals_parser.zig (new)\n- wiki/vault/design/signal-grammar.md (new)\n- src/worker_pool.zig (integrate parser)\n- src/streaming.zig (expose text extraction for parsing)\n\n## Depends On\n\n- noface-2ua (protocol specification defines what signals exist)","status":"open","priority":2,"issue_type":"feature","created_at":"2025-12-10T15:38:47.524236-08:00","updated_at":"2025-12-10T15:38:47.524236-08:00","labels":["implementation","pl-foundations"],"dependencies":[{"issue_id":"noface-31u","depends_on_id":"noface-2ua","type":"blocks","created_at":"2025-12-10T15:40:52.075431-08:00","created_by":"daemon"}]}
{"id":"noface-3eh","title":"Add timeout handling for hung agents","description":"If an agent process doesn't produce output for a configurable timeout (default: 5 minutes), kill it and report an error.\n\nThis prevents noface from hanging indefinitely if Claude or Codex gets stuck.\n\nAdd config option:\n```toml\n[agents]\ntimeout_seconds = 300\n```","acceptance_criteria":"- Agent process that produces no output for agents.timeout_seconds (default 300s) is terminated and marked failed\n- Config accepts override; zero/negative values rejected\n- Timeout is logged and surfaced in run summary/exit codes\n- Worker resources/locks are cleaned up after timeout and retriable\n- Tests cover timeout kill path and recovery","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-09T23:00:26.530001-08:00","updated_at":"2025-12-10T07:11:30.00072-08:00","closed_at":"2025-12-10T07:11:30.00072-08:00"}
{"id":"noface-3le","title":"Add static analysis integration (hard/soft gates)","description":"Integrate whatever static analysis the repo already has.\n\nHard gates (block on failure):\n- Type errors (zig build, tsc, mypy)\n- Formatter failures (zig fmt, prettier)\n\nSoft gates (log, maybe create follow-up):\n- New lint warnings\n- Security scanner findings (unless critical)\n\nConfig:\n[verification.static_analysis]\nhard_gates = ['zig build', 'zig fmt --check']\nsoft_gates = ['clippy', 'eslint']\n\nReference: [[verification]] design doc","status":"open","priority":2,"issue_type":"feature","created_at":"2025-12-10T12:04:46.516271-08:00","updated_at":"2025-12-10T12:04:46.516271-08:00","labels":["static-analysis","verification"]}
{"id":"noface-3m7","title":"Add judge agent for semantic verification","description":"Add semantic check step for complex issues.\n\nOption 1: Explicit reasoning\n- Have implementer/reviewer write: 'Here is how the change addresses the issue...'\n- Check coherence between explanation and diff\n\nOption 2: Judge agent\n- Input: issue description + old code + new code\n- Question: 'Does this change resolve the described behavior? Is anything missing or unrelated?'\n\nDoesn't need to be perfect; even catching obvious mismatches is a big win.\n\nReference: [[verification]] design doc","status":"open","priority":2,"issue_type":"feature","created_at":"2025-12-10T12:04:48.718307-08:00","updated_at":"2025-12-10T12:04:48.718307-08:00","labels":["semantic","verification"]}
{"id":"noface-4h2","title":"Align CLI flags with design doc naming (scrum vs planner)","description":"Design doc documents scrum flags/keys (--no-scrum, --scrum-interval, [passes].scrum_enabled/scrum_interval) but the CLI/template only expose planner_* names. Users following the README can't configure passes correctly.","design":"README.md \u003e CLI Options \u0026 Configuration","acceptance_criteria":"- CLI supports --no-scrum/--scrum-interval flags; --help text uses design terminology (keep planner aliases for compatibility).\\n- Config parser accepts scrum_enabled/scrum_interval keys and init template emits them.\\n- Tests cover new flags/config paths; planner behavior continues to work through unified config fields.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-09T23:18:09.11498-08:00","updated_at":"2025-12-10T14:15:09.651456-08:00","closed_at":"2025-12-10T14:15:09.651456-08:00","comments":[{"id":5,"issue_id":"noface-4h2","author":"femtomc","text":"MANIFEST: primary=[src/main.zig,src/config.zig,README.md] read=[src/loop.zig] forbidden=[src/web.zig]","created_at":"2025-12-10T17:14:33Z"},{"id":14,"issue_id":"noface-4h2","author":"femtomc","text":"MANIFEST: primary=[src/main.zig,src/config.zig,README.md] read=[src/loop.zig] forbidden=[]","created_at":"2025-12-10T20:40:21Z"},{"id":22,"issue_id":"noface-4h2","author":"femtomc","text":"MANIFEST: primary=[src/main.zig,src/config.zig,README.md] read=[src/loop.zig] forbidden=[]","created_at":"2025-12-10T21:37:01Z"}]}
{"id":"noface-4qv","title":"Research: Model orchestration passes as algebraic effects","description":"## Summary\n\nThe orchestration loop in loop.zig runs several \"passes\" (planner, quality, iteration) with complex control flow: event-driven vs interval modes, early exit conditions, state persistence. This logic is interleaved and hard to reason about.\n\nInvestigate modeling passes as **algebraic effects** to:\n- Separate pass logic from control flow\n- Enable composition and testing of passes\n- Make side effects explicit\n\n## Background: Algebraic Effects\n\nAlgebraic effects (Plotkin \u0026 Power, 2003) generalize exceptions, state, I/O:\n\n```\neffect Pass {\n    getNextIssue : () → Option\u003cIssue\u003e\n    runAgent : Issue → Result\n    saveState : () → ()\n    yield : Duration → ()\n}\n\n// Handler provides implementation\nhandle plannerPass() with {\n    getNextIssue() → beads.ready()\n    runAgent(i) → claude.run(i)\n    saveState() → state.save()\n    yield(d) → sleep(d)\n}\n```\n\nBenefits:\n- **Testability**: Mock handler for testing\n- **Composition**: Combine effects (Logging + FileAccess + AgentComm)\n- **Control flow**: Handler decides whether to continue, retry, abort\n\n## Current Pass Architecture\n\n```zig\n// loop.zig - everything interleaved\npub fn run(self: *AgentLoop) !void {\n    while (!self.isInterrupted()) {\n        // Planner pass (conditional)\n        if (shouldRunPlanner()) {\n            try self.runPlannerPass();\n        }\n        \n        // Quality pass (conditional)\n        if (shouldRunQuality()) {\n            try self.runQualityPass();\n        }\n        \n        // Iteration (complex control flow)\n        const batch_executed = try self.runBatchIteration();\n        if (!batch_executed) {\n            // Event-driven logic...\n        }\n        \n        // State save\n        self.saveState();\n        \n        // Sleep\n        std.Thread.sleep(5 * std.time.ns_per_s);\n    }\n}\n```\n\n## Proposed Effect Model\n\n```\n// Effects for orchestration\neffect Orchestration {\n    // Issue management\n    getReadyIssues : () → List\u003cIssue\u003e\n    updateIssue : (IssueId, Status) → ()\n    \n    // Agent execution\n    runAgent : (Issue, Manifest) → AgentResult\n    runReview : Issue → ReviewResult\n    \n    // Scheduling\n    acquireLocks : (Issue, Manifest) → Option\u003cLockGuard\u003e\n    releaseLocks : Issue → ()\n    \n    // Persistence\n    saveState : () → ()\n    loadState : () → State\n    \n    // Control\n    yield : Duration → ()\n    checkInterrupt : () → Bool\n}\n\n// Planner pass as pure function over effects\nplannerPass : Eff[Orchestration] Bool\nplannerPass = do\n    issues \u003c- getReadyIssues()\n    batches \u003c- computeBatches(issues)\n    for batch in batches:\n        for issue in batch:\n            guard \u003c- acquireLocks(issue) ? continue\n            result \u003c- runAgent(issue)\n            releaseLocks(issue)\n            updateIssue(issue, result.status)\n    saveState()\n    return !isEmpty(batches)\n```\n\n## Deliverables\n\n1. **Effect model document** in wiki/vault/design/effect-model.md\n   - Effect signatures for orchestration\n   - Handler implementations (production vs test)\n   - Composition rules\n\n2. **Feasibility analysis**\n   - How to approximate in Zig (no native effects)\n   - Struct with function pointers as \"handler\"\n   - Comparison: effect-style vs current procedural\n\n3. **Prototype** (if feasible)\n   - Refactor one pass (e.g., plannerPass) to effect style\n   - Demonstrate testability improvement\n\n## Implementation Approaches in Zig\n\n### Option A: Vtable-style handler\n\n```zig\nconst OrchestratorEffects = struct {\n    getReadyIssues: *const fn () []Issue,\n    runAgent: *const fn (Issue) AgentResult,\n    saveState: *const fn () void,\n    // ...\n};\n\nfn plannerPass(effects: OrchestratorEffects) bool {\n    const issues = effects.getReadyIssues();\n    // ...\n}\n```\n\n### Option B: Comptime-generic handler\n\n```zig\nfn plannerPass(comptime Handler: type) bool {\n    const issues = Handler.getReadyIssues();\n    // ...\n}\n\n// Production\nconst ProdHandler = struct {\n    fn getReadyIssues() []Issue { ... }\n};\n\n// Test\nconst MockHandler = struct {\n    fn getReadyIssues() []Issue { return \u0026test_issues; }\n};\n```\n\n## References\n\n- Plotkin, G. \u0026 Power, J. (2003). \"Algebraic Operations and Generic Effects\"\n- Kammar, O. et al. (2013). \"Handlers in Action\" - practical algebraic effects\n- Koka language: https://koka-lang.github.io/ - effects in practice\n- Pretnar, M. (2015). \"An Introduction to Algebraic Effects and Handlers\"\n- Eff language: https://www.eff-lang.org/\n\n## Files to Create/Modify\n\n- wiki/vault/design/effect-model.md (new)\n- src/effects.zig (prototype, optional)","status":"open","priority":3,"issue_type":"feature","created_at":"2025-12-10T15:40:38.596178-08:00","updated_at":"2025-12-10T15:40:38.596178-08:00","labels":["pl-foundations","research"]}
{"id":"noface-4s3","title":"BLOCKED_BY_FILE signal fires for unlocked files","description":"Workers output BLOCKED_BY_FILE signals for files that aren't actually locked by other workers.\n\n**Symptom:**\n```\n[POOL] Worker 0 reported blocked on \u003cpath/to/file.zig\u003e, but file is not locked - ignoring\n```\n\n**Root cause analysis:**\n\nThe instruction tells Claude to output `BLOCKED_BY_FILE: \u003cpath\u003e` when it sees errors in files not in its manifest, assuming another worker must be editing them. But this assumption is often wrong:\n\n1. **Pre-existing bugs**: The file might have a bug nobody is working on\n2. **Cascading errors**: Claude's changes cause errors in dependent files that aren't locked\n3. **Transient state**: Another worker finished and left inconsistent state\n4. **Race condition**: Lock released between Claude detecting conflict and orchestrator checking\n5. **Path mismatch**: No normalization (e.g., `./src/foo.zig` vs `src/foo.zig`)\n\n**Current behavior:**\nThe orchestrator correctly ignores these false positives and clears the blocked flag. The warning is working as designed but is noisy.\n\n**Potential fixes:**\n1. Improve Claude instructions - only signal blocked if confident another worker is actively editing\n2. Add path normalization before lock comparison\n3. Downgrade from `logWarn` to `logDebug` since it's expected\n4. Have Claude check if file is in another worker's manifest before signaling","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-10T16:33:57.582726-08:00","updated_at":"2025-12-10T18:36:29.87207-08:00","closed_at":"2025-12-10T18:36:29.87207-08:00","labels":["blocking","worker-pool"]}
{"id":"noface-5g3","title":"Implement soft gate to follow-up issue creation","description":"When soft gates fail, create follow-up issues instead of blocking.\n\nSoft gates:\n- Lint warnings\n- Coverage thresholds\n- Reviewer 'nit' comments\n\nPolicy:\n- Automated merge requires all hard gates\n- Soft gate failures:\n  - Either block and open follow-up issue, or\n  - Allow merge but log warnings and create cleanup issues\n\nReference: [[verification]] design doc","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-10T12:04:56.728197-08:00","updated_at":"2025-12-10T12:04:56.728197-08:00","labels":["verification"]}
{"id":"noface-5r0","title":"Implement dynamic context budget based on issue complexity","description":"Make context budget dynamic instead of fixed max_context_docs = 5.\n\nApproach:\n- Define target fraction of prompt tokens for retrieved docs (e.g., 30-40%)\n- Fill slot with as many top-ranked docs as fit\n- Complexity heuristics:\n  - More files / cross-cutting change → allow more docs\n  - Tiny, local change → maybe 0-2 docs only\n\nKeep max_context_docs as hard cap, but choose K ∈ [0, max] per issue.\n\nReference: [[context-injection]] design doc","status":"open","priority":2,"issue_type":"feature","created_at":"2025-12-10T12:01:45.323206-08:00","updated_at":"2025-12-10T12:01:45.323206-08:00","labels":["context","prompts"],"comments":[{"id":61,"issue_id":"noface-5r0","author":"femtomc","text":"MANIFEST: primary=[src/loop.zig,src/config.zig,src/monowiki.zig] read=[src/bm25.zig,src/state.zig] forbidden=[]","created_at":"2025-12-11T00:21:49Z"},{"id":70,"issue_id":"noface-5r0","author":"femtomc","text":"MANIFEST: primary=[src/core/loop.zig,src/integrations/monowiki.zig,src/core/config.zig] read=[src/core/prompts.zig] forbidden=[web/]","created_at":"2025-12-11T04:38:06Z"}]}
{"id":"noface-6ql","title":"Implement exclusion list for context retrieval","description":"Define explicit exclusions for context retrieval:\n\nPath-based:\n- vendor/, node_modules/, dist/, build/, .cache/\n- *.min.js, large generated protobufs\n\nSize-based:\n- Files \u003e X KB not included unless explicitly requested\n\nType-based:\n- Binary blobs, lockfiles, big JSON dumps\n\nImplement in retrieval pipeline so excluded files never show up as candidates.\n\nReference: [[context-injection]] design doc","status":"in_progress","priority":2,"issue_type":"task","created_at":"2025-12-10T12:01:52.219219-08:00","updated_at":"2025-12-10T16:25:11.56105-08:00","labels":["context","retrieval"],"comments":[{"id":63,"issue_id":"noface-6ql","author":"femtomc","text":"MANIFEST: primary=[src/monowiki.zig,src/config.zig] read=[src/loop.zig,src/bm25.zig] forbidden=[]","created_at":"2025-12-11T00:21:57Z"}]}
{"id":"noface-7qx","title":"Wire monowiki design vault into planner","description":"Planner/implementation runs currently don't know where the design documents live. Configure noface to use the hongseok monowiki vault so the planner and agents automatically pull context from the orchestrator and microagent design docs.\nInclude a way to set the vault path in .noface.toml/CLI, validate monowiki availability, and surface a clear warning when the vault is missing.","design":"orchestrator, microagent (hongseok monowiki)","acceptance_criteria":"- .noface.toml supports a [monowiki] block pointing at /Users/femtomc/docs/hongseok/vault (or equivalent CLI flag) and the path is read by noface at startup\n- Planner/implementation prompts show monowiki commands against that vault and can fetch orchestrator/microagent docs when available\n- Missing monowiki CLI or vault path produces a non-fatal warning and planner continues without crashing","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-09T23:07:11.610328-08:00","updated_at":"2025-12-09T23:14:23.005181-08:00","closed_at":"2025-12-09T23:14:23.005181-08:00"}
{"id":"noface-8fp","title":"Verify file changes against manifest after agent runs","description":"After an implementation agent completes, check git diff against the issue's manifest. If agent modified files outside primary_files or touched forbidden_files, rollback and record violation. Implement in loop.zig after agent completion.","acceptance_criteria":"verifyManifestCompliance function checks git diff; Unauthorized changes trigger rollback; Violations recorded in state.AttemptRecord; Agent retried with stricter prompt on violation","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-12-10T06:45:55.868754-08:00","updated_at":"2025-12-10T08:02:54.861142-08:00","closed_at":"2025-12-10T08:02:54.861142-08:00","dependencies":[{"issue_id":"noface-8fp","depends_on_id":"noface-gsk","type":"blocks","created_at":"2025-12-10T06:46:13.284984-08:00","created_by":"daemon"}]}
{"id":"noface-8x3","title":"Add hybrid ranking for context (BM25 + embeddings)","description":"Replace simple wikilink fetching with hybrid ranking:\n\nPipeline:\n1. Candidate generation:\n   - Wikilinks / explicit references from issue\n   - BM25 search (already have src/bm25.zig)\n\n2. Re-ranking:\n   - Embedding similarity (doc ↔ issue description)\n\n3. Final score:\n   score = α * BM25 + β * embedding_score + boost_if_explicitly_linked\n\nReference: [[context-injection]] design doc","status":"open","priority":2,"issue_type":"feature","created_at":"2025-12-10T12:01:47.763258-08:00","updated_at":"2025-12-10T12:01:47.763258-08:00","labels":["context","retrieval"],"comments":[{"id":62,"issue_id":"noface-8x3","author":"femtomc","text":"MANIFEST: primary=[src/monowiki.zig,src/bm25.zig,src/loop.zig,src/config.zig] read=[src/root.zig,src/process.zig] forbidden=[]","created_at":"2025-12-11T00:21:53Z"},{"id":71,"issue_id":"noface-8x3","author":"femtomc","text":"MANIFEST: primary=[src/integrations/monowiki.zig,src/core/loop.zig,src/core/config.zig] read=[src/util/bm25.zig] forbidden=[web/]","created_at":"2025-12-11T04:38:11Z"}]}
{"id":"noface-8yn","title":"Implement: RAII-style lock lifecycle with linear resource tracking","description":"## Summary\n\nFile locks in noface are acquired via tryAcquireLocks() and released via releaseLocks(). The current implementation requires manual release calls, which can be forgotten—especially in error paths. This has caused lock leaks in edge cases.\n\nImplement a **linear-types-inspired** lock management pattern using Zig's RAII capabilities (defer/errdefer) to ensure locks are always released.\n\n## Background: Linear Types \u0026 RAII\n\n**Linear types** (Girard, 1987) ensure resources are used exactly once:\n```\nLock : linear type\nacquire : FilePath → Lock\nrelease : Lock → ()  -- Consumes the lock\n```\n\n**RAII** (Resource Acquisition Is Initialization) ties resource lifetime to scope:\n```cpp\n{\n    LockGuard guard(file);  // Acquires\n    // ... use file ...\n}  // Automatically releases\n```\n\nRust's ownership system is the most successful practical application of linear types.\n\n## Current Implementation (Problematic)\n\n```zig\n// Acquisition (state.zig:tryAcquireLocks)\npub fn tryAcquireLocks(self: *OrchestratorState, issue_id: []const u8, \n                       manifest: Manifest, worker_id: u32) !bool\n\n// Release (state.zig:releaseLocks) - MANUAL, can be forgotten\npub fn releaseLocks(self: *OrchestratorState, issue_id: []const u8) void\n\n// Usage in worker_pool.zig - multiple release points, easy to miss\nif (!locks_acquired) continue;\nself.startWorker(worker_id, issue_id) catch |err| {\n    self.state.releaseLocks(issue_id);  // Must remember!\n    continue;\n};\n// ... later ...\nself.state.releaseLocks(result.issue_id);  // And here!\n```\n\n## Proposed Design\n\n```zig\n/// LockGuard: RAII wrapper for acquired locks\npub const LockGuard = struct {\n    state: *OrchestratorState,\n    issue_id: []const u8,\n    released: bool = false,\n\n    /// Release locks - idempotent\n    pub fn release(self: *LockGuard) void {\n        if (!self.released) {\n            self.state.releaseLocks(self.issue_id);\n            self.released = true;\n        }\n    }\n\n    /// Destructor - ensures release on scope exit\n    pub fn deinit(self: *LockGuard) void {\n        self.release();\n    }\n};\n\n/// Acquire locks, returning guard that auto-releases on scope exit\npub fn acquireLocksGuarded(self: *OrchestratorState, issue_id: []const u8,\n                           manifest: Manifest, worker_id: u32) !?LockGuard {\n    if (!try self.tryAcquireLocks(issue_id, manifest, worker_id)) {\n        return null;\n    }\n    return LockGuard{ .state = self, .issue_id = issue_id };\n}\n\n// Usage:\nvar guard = try self.state.acquireLocksGuarded(issue_id, manifest, worker_id) orelse continue;\ndefer guard.deinit();  // ALWAYS releases, even on error\n\ntry self.startWorker(worker_id, issue_id);\n// On success, transfer ownership: guard.released = true, don't auto-release\n```\n\n## Design Considerations\n\n1. **Ownership transfer**: When worker starts successfully, lock ownership transfers to worker\n   - Guard marks as released, doesn't auto-release\n   - Worker completion triggers explicit release\n\n2. **Error paths**: errdefer ensures release on any error during worker setup\n\n3. **Idempotence**: Multiple release() calls are safe (no-op after first)\n\n4. **Debugging**: Track lock acquisition/release in transcript DB\n\n## Deliverables\n\n1. **LockGuard struct** in src/state.zig\n   - RAII semantics with defer/deinit\n   - Ownership transfer support\n   - Debug logging\n\n2. **Refactored lock usage** in worker_pool.zig\n   - All lock acquisitions use guarded variant\n   - Remove manual releaseLocks() calls\n   - Use defer/errdefer patterns\n\n3. **Tests** for lock lifecycle\n   - Normal path: acquire → use → release\n   - Error path: acquire → error → auto-release\n   - Ownership transfer: acquire → transfer → worker releases\n\n## References\n\n- Girard, J.Y. (1987). \"Linear Logic\" - theoretical foundation\n- Wadler, P. (1990). \"Linear Types Can Change the World!\"\n- Rust ownership: https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html\n- Zig errdefer: https://ziglang.org/documentation/master/#errdefer\n\n## Files to Modify\n\n- src/state.zig (add LockGuard, acquireLocksGuarded)\n- src/worker_pool.zig (refactor to use guards)","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-10T15:39:14.548037-08:00","updated_at":"2025-12-10T21:38:06.812489-08:00","closed_at":"2025-12-10T21:38:06.812489-08:00","labels":["implementation","pl-foundations"],"dependencies":[{"issue_id":"noface-8yn","depends_on_id":"noface-0px","type":"blocks","created_at":"2025-12-10T15:40:52.155909-08:00","created_by":"daemon"}]}
{"id":"noface-a2b","title":"Add model escalation policy","description":"Define a simple model escalation policy for failures:\n\nFor each issue:\n- First 1-2 attempts: default_model (cheaper)\n- If still failing with correctable errors (tests, syntax): escalate to strong_model\n- Cap total attempts across all models\n\nConfig:\n[retry]\ndefault_model = 'claude-sonnet'\nescalation_model = 'claude-opus'\nescalate_after_attempts = 2\nmax_total_attempts = 5\n\nReference: [[failure-recovery]] design doc","status":"open","priority":2,"issue_type":"feature","created_at":"2025-12-10T12:03:44.827387-08:00","updated_at":"2025-12-10T12:03:44.827387-08:00","labels":["config","failure-recovery"]}
{"id":"noface-a68","title":"Epic: Modularize god files (loop.zig, state.zig)","description":"## Summary\n\nloop.zig (2721 lines) and state.zig (2116 lines) have grown into \"god files\" that violate single responsibility principle. This epic tracks the modularization effort.\n\n## Current State\n\n**loop.zig responsibilities (should be ~5 modules):**\n1. Orchestration loop coordination\n2. Prompt building (implementation, planner, quality, worker)\n3. Pass execution (planner, quality)\n4. Manifest compliance verification\n5. Git operations\n6. Context fetching (monowiki, code refs)\n\n**state.zig responsibilities (should be ~2-3 modules):**\n1. Data structures (Manifest, Worker, Issue, Batch, Lock)\n2. OrchestratorState management\n3. JSON serialization (manual, should use std.json)\n4. Lock management\n\n## Target Architecture\n\n```\nsrc/\n├── loop.zig          # Orchestration coordination only (~500 lines)\n├── prompts.zig       # All prompt building\n├── passes.zig        # Planner, quality, future passes\n├── compliance.zig    # Manifest enforcement\n├── git.zig           # Git operations\n├── state.zig         # Data structures + state (~800 lines)\n├── worker_pool.zig   # (already focused)\n└── ...\n```\n\n## Child Issues\n\n- noface-2d6: Extract prompt builders → prompts.zig\n- noface-grl: Extract passes → passes.zig\n- noface-cb8: Extract compliance → compliance.zig\n- noface-tp9: Extract git ops → git.zig\n- noface-y9e: Replace manual JSON with std.json\n\n## Success Criteria\n\n1. loop.zig \u003c 600 lines\n2. state.zig \u003c 1000 lines\n3. Each new module has unit tests\n4. No functionality regression\n5. Build and test pass\n\n## Suggested Order\n\n1. noface-tp9 (git.zig) - no dependencies, enables compliance extraction\n2. noface-2d6 (prompts.zig) - no dependencies, pure functions\n3. noface-cb8 (compliance.zig) - depends on git.zig\n4. noface-grl (passes.zig) - depends on prompts.zig\n5. noface-y9e (JSON refactor) - can be parallel with others","status":"open","priority":1,"issue_type":"epic","created_at":"2025-12-10T15:46:00.384644-08:00","updated_at":"2025-12-10T15:46:00.384644-08:00","labels":["modularization","refactor"],"dependencies":[{"issue_id":"noface-a68","depends_on_id":"noface-tp9","type":"blocks","created_at":"2025-12-10T15:56:57.749736-08:00","created_by":"daemon"},{"issue_id":"noface-a68","depends_on_id":"noface-2d6","type":"blocks","created_at":"2025-12-10T15:57:01.573428-08:00","created_by":"daemon"},{"issue_id":"noface-a68","depends_on_id":"noface-y9e","type":"blocks","created_at":"2025-12-10T15:57:04.889773-08:00","created_by":"daemon"},{"issue_id":"noface-a68","depends_on_id":"noface-cb8","type":"blocks","created_at":"2025-12-10T15:57:08.460803-08:00","created_by":"daemon"},{"issue_id":"noface-a68","depends_on_id":"noface-grl","type":"blocks","created_at":"2025-12-10T15:57:12.37544-08:00","created_by":"daemon"}],"comments":[{"id":48,"issue_id":"noface-a68","author":"femtomc","text":"MANIFEST: primary=[] read=[] forbidden=[]","created_at":"2025-12-10T23:54:37Z"}]}
{"id":"noface-a89","title":"Implement: Runtime manifest enforcement via tool interception","description":"## Summary\n\nCurrently, manifest compliance is checked **post-hoc**: agents run freely, then git diff is compared against manifest. Violations are detected after the fact, requiring rollback and retry.\n\nImplement **preventive enforcement**: intercept file operations at tool invocation time and reject violations immediately. This provides faster feedback and prevents wasted computation.\n\n## Background: Capability Enforcement\n\nObject-capability systems enforce access at the point of use:\n```\n// Traditional: check after action\nagent.run()\ndiff = git_diff()\nif violates(diff, manifest): rollback()\n\n// Capability: check before action  \nfor each tool_call in agent.stream:\n    if !manifest.allows(tool_call): reject(\"Access denied\")\n    else: execute(tool_call)\n```\n\n## Current Architecture\n\n```\nClaude Process                    Orchestrator\n    |                                  |\n    |--[stdout: JSON stream]----------\u003e|\n    |   { \"tool_use\": \"Edit\",          | (currently: just log)\n    |     \"input\": { \"file_path\": X }} |\n    |                                  |\n    |\u003c--[stdin: tool result]-----------|\n    |                                  |\n    ... agent completes ...            |\n                                       |\n                            git diff → manifest check → rollback?\n```\n\n## Proposed Architecture\n\n```\nClaude Process                    Orchestrator (with enforcement)\n    |                                  |\n    |--[stdout: JSON stream]----------\u003e|\n    |   { \"tool_use\": \"Edit\",          | CHECK manifest.allows(\"Edit\", X)\n    |     \"input\": { \"file_path\": X }} |   if NO: inject error result\n    |                                  |   if YES: let through\n    |\u003c--[stdin: tool result]-----------|\n    |   { \"error\": \"Access denied...\" }|  (or normal result)\n    |                                  |\n```\n\n## Implementation Approach\n\n### Option A: Orchestrator-mediated tool execution\n\n1. Agent runs with a custom tool interface (not direct file access)\n2. Orchestrator intercepts tool calls from stream-json\n3. Orchestrator checks manifest before executing tool\n4. Orchestrator injects result back to agent\n\n**Challenge**: Claude's stream-json doesn't support external tool mediation in current architecture. Agent expects to execute tools itself.\n\n### Option B: Claude hooks (if available)\n\n1. Use Claude Code hooks system to intercept tool calls\n2. Hook validates against manifest\n3. Blocks forbidden operations\n\n**Challenge**: Need to investigate if hooks can reject tool calls.\n\n### Option C: Sandboxed execution with allowlist\n\n1. Run Claude with filesystem sandbox (container/seccomp)\n2. Only allow access to manifest-specified files\n3. OS-level enforcement\n\n**Challenge**: Complex setup, may break legitimate reads.\n\n### Option D: Pre/post validation with fast fail (incremental improvement)\n\n1. Before starting worker: validate manifest files exist\n2. During execution: periodically check git status for violations\n3. On violation: kill worker immediately (not wait for completion)\n\n**Challenge**: Still reactive, but faster than full post-hoc.\n\n## Recommended Approach\n\nStart with **Option D** (fast-fail validation) as incremental improvement:\n- Add periodic git status checks during worker execution\n- Kill worker immediately on violation\n- Log violation details for debugging\n\nThen investigate **Option B** (hooks) for true preventive enforcement.\n\n## Deliverables\n\n1. **Periodic violation checker** in worker_pool.zig\n   - Run git status every N seconds during worker execution\n   - Detect modifications to non-manifest files\n   - Kill worker on violation with clear error\n\n2. **Violation reporting** in transcript DB\n   - Log attempted violation (file, operation, time)\n   - Useful for tuning manifest generation\n\n3. **Investigation doc** for true interception\n   - Claude hooks capabilities\n   - MCP server approach\n   - Sandbox options\n\n## References\n\n- Miller, M. (2006). \"Robust Composition\" - object capabilities\n- wiki/vault/design/manifests.md - existing design, section on violations\n- Claude Code hooks: https://docs.anthropic.com/en/docs/claude-code/hooks\n\n## Depends On\n\n- noface-0px (capability model design)\n\n## Files to Modify\n\n- src/worker_pool.zig (add violation checker)\n- src/state.zig (violation logging)\n- wiki/vault/design/capability-enforcement.md (new investigation doc)","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-10T15:39:43.857234-08:00","updated_at":"2025-12-10T21:35:51.803792-08:00","closed_at":"2025-12-10T21:35:51.803792-08:00","labels":["implementation","pl-foundations"],"dependencies":[{"issue_id":"noface-a89","depends_on_id":"noface-0px","type":"blocks","created_at":"2025-12-10T15:40:52.195653-08:00","created_by":"daemon"}]}
{"id":"noface-a8g","title":"Replace ad-hoc TOML parsing with a real parser + validation","description":"Config.parseToml (src/config.zig) manually splits lines and only handles trivial key=value strings; it ignores inline comments, escapes, arrays, and nested tables, and silently trims quotes instead of parsing types. Valid TOML like strings containing '=' or booleans with inline comments are misread, which makes .noface.toml brittle and hard to debug. Swap in a proper TOML parser or at least a stricter validation layer that rejects malformed input and surfaces errors with file/line context.","status":"in_progress","priority":2,"issue_type":"task","created_at":"2025-12-10T08:59:16.677421-08:00","updated_at":"2025-12-10T14:39:31.151796-08:00","comments":[{"id":10,"issue_id":"noface-a8g","author":"femtomc","text":"MANIFEST: primary=[src/config.zig,src/main.zig] read=[README.md,src/loop.zig] forbidden=[src/web.zig]","created_at":"2025-12-10T17:14:54Z"},{"id":19,"issue_id":"noface-a8g","author":"femtomc","text":"MANIFEST: primary=[src/config.zig,build.zig,build.zig.zon] read=[src/main.zig,README.md] forbidden=[]","created_at":"2025-12-10T20:40:41Z"},{"id":26,"issue_id":"noface-a8g","author":"femtomc","text":"MANIFEST: primary=[src/config.zig,build.zig,build.zig.zon,src/main.zig] read=[README.md,src/loop.zig] forbidden=[]","created_at":"2025-12-10T21:37:23Z"}]}
{"id":"noface-ajs","title":"Add reviewer pass with risk-based triggering","description":"Add a dedicated reviewer agent pass, but only for high-risk changes.\n\nTrigger reviewer when:\n- Diff size \u003e threshold\n- Changed files in security/, auth/, infra/, config/\n- No tests exist or coverage is low\n\nSkip for low-risk, tiny changes where tests are strong.\n\nReviewer inputs: issue description, old vs new diff, test results\nReviewer outputs: OK / NOT_OK / NEEDS_HUMAN + specific comments\n\nReference: [[multi-pass]] and [[verification]] design docs","status":"open","priority":2,"issue_type":"feature","created_at":"2025-12-10T12:02:37.985361-08:00","updated_at":"2025-12-10T12:02:37.985361-08:00","labels":["multi-pass","reviewer"],"comments":[{"id":64,"issue_id":"noface-ajs","author":"femtomc","text":"MANIFEST: primary=[src/loop.zig,src/config.zig,src/state.zig] read=[src/worker_pool.zig,src/streaming.zig] forbidden=[]","created_at":"2025-12-11T00:22:02Z"},{"id":72,"issue_id":"noface-ajs","author":"femtomc","text":"MANIFEST: primary=[src/core/loop.zig,src/core/prompts.zig,src/core/config.zig,src/core/state.zig] read=[src/core/worker_pool.zig] forbidden=[web/]","created_at":"2025-12-11T04:38:16Z"}]}
{"id":"noface-ang","title":"Implement replan-on-violation flow","description":"When an agent attempts to touch a non-manifest file:\n1. Reject that attempt\n2. Spawn a replan: run planner again with the new file explicitly mentioned\n3. Re-run implementation under the new manifest\n\nNever accept a violation directly - use violations as hints for replanning.\n\nReference: [[manifests]] design doc","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-10T12:00:19.182053-08:00","updated_at":"2025-12-10T21:35:51.804237-08:00","closed_at":"2025-12-10T21:35:51.804237-08:00","labels":["manifests","planner"],"dependencies":[{"issue_id":"noface-ang","depends_on_id":"noface-ms6","type":"blocks","created_at":"2025-12-10T16:20:38.561751-08:00","created_by":"daemon"}],"comments":[{"id":28,"issue_id":"noface-ang","author":"femtomc","text":"MANIFEST: primary=[src/loop.zig,src/state.zig,src/worker_pool.zig] read=[src/process.zig,README.md] forbidden=[]","created_at":"2025-12-10T21:37:33Z"},{"id":50,"issue_id":"noface-ang","author":"femtomc","text":"MANIFEST: primary=[src/loop.zig,src/state.zig,src/worker_pool.zig] read=[src/config.zig] forbidden=[]","created_at":"2025-12-10T23:54:44Z"},{"id":56,"issue_id":"noface-ang","author":"femtomc","text":"MANIFEST: primary=[src/loop.zig,src/state.zig] read=[src/worker_pool.zig,src/process.zig] forbidden=[]","created_at":"2025-12-11T00:18:33Z"}]}
{"id":"noface-au9","title":"State persistence relies on hand-rolled JSON with no schema/versioning","description":"State save/load in src/state.zig (writeJson/parseJson around lines 260-520) manually concatenates and string-searches JSON. Escaping, nesting, and unknown fields are not handled, so any brace or quote in ids/notes can corrupt state, and additions silently drop on load. There is no schema or version upgrade path, so state.json round-trips are brittle and hard to test. Replace with structured encode/decode (std.json or a serde helper) plus explicit versioned schema and migrations, and add round-trip tests that cover manifests, batches, locks, attempt records, and future fields.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-10T14:28:28.245205-08:00","updated_at":"2025-12-10T14:28:28.245205-08:00"}
{"id":"noface-b0h","title":"noface serve is missing live dashboard APIs","description":"The Zig web server at src/web.zig only serves static assets plus /api/issues and /api/state; /api/sessions returns {} and there is no /ws endpoint. The frontend (web/src/hooks/useWebSocket.ts) expects a websocket for live updates and session playback, and the Bun dev server (web/server/index.ts) streams issues/state and summarizes session logs from /tmp. Bring noface serve to parity by wiring a websocket endpoint and real /api/sessions that reads recent noface-session-*.json logs.","status":"in_progress","priority":2,"issue_type":"feature","created_at":"2025-12-10T08:58:59.697929-08:00","updated_at":"2025-12-10T13:40:54.15108-08:00","comments":[{"id":9,"issue_id":"noface-b0h","author":"femtomc","text":"MANIFEST: primary=[src/web.zig] read=[web/server/index.ts,web/src/hooks/useWebSocket.ts,src/web_assets.zig] forbidden=[src/loop.zig]","created_at":"2025-12-10T17:14:49Z"},{"id":18,"issue_id":"noface-b0h","author":"femtomc","text":"MANIFEST: primary=[src/web.zig,src/web_assets.zig,web/src/hooks/useWebSocket.ts] read=[web/server/index.ts,src/state.zig,src/process.zig] forbidden=[]","created_at":"2025-12-10T20:40:37Z"},{"id":25,"issue_id":"noface-b0h","author":"femtomc","text":"MANIFEST: primary=[src/web.zig] read=[web/server/index.ts,web/src/hooks/useWebSocket.ts,README.md,src/transcript.zig] forbidden=[]","created_at":"2025-12-10T21:37:17Z"}]}
{"id":"noface-b71","title":"Doc agent: Template-driven writer with structured output","description":"## Phase 2: Template-Driven Writer\n\nBasic documentation generation using enforced templates.\n\n### Templates to Implement\n\n**API Reference:**\n```markdown\n### \\`function_name\\`\nBrief one-line description.\n\n**Parameters:**\n- \\`param\\` (type): Description\n\n**Returns:**\n- type: Description\n\n**Example:**\n(code block)\n\n**Notes:**\n- Edge cases\n```\n\n**Tutorial:**\n```markdown\n### Title\nOne sentence: what you will learn.\n\n**Prerequisites:**\n- Assumed knowledge\n\n**Steps:**\n1. Step with code\n\n**Result:**\nWhat user should see\n```\n\n### Reader Profile\n\nInclude in prompt:\n- Role (backend dev, newcomer, etc.)\n- Familiarity level\n- What to skip vs explain\n\n### Implementation\n\n1. Select template based on DOC_TASK type\n2. Gather context (function signature, types, related code)\n3. Generate draft with strict template adherence\n4. Output markdown\n\nSee: [[design/doc-agent]]","status":"open","priority":3,"issue_type":"feature","created_at":"2025-12-10T15:14:51.739485-08:00","updated_at":"2025-12-10T15:14:51.739485-08:00","comments":[{"id":37,"issue_id":"noface-b71","author":"femtomc","text":"References: wiki/vault/design/doc-agent.md, wiki/vault/research/technical-writing-agent.md","created_at":"2025-12-10T23:20:08Z"}]}
{"id":"noface-bfd","title":"Show progress indicator during long operations","description":"Add a simple progress indicator (spinner or dots) when waiting for:\n- Agent responses\n- Build commands\n- Test runs\n\nThis gives users feedback that noface is still working.","acceptance_criteria":"- Progress indicator (spinner/dots) shows during agent responses, build commands, and test runs\n- Indicator respects quiet/non-interactive modes and does not garble normal logs\n- Hides/finishes cleanly when operation completes or errors\n- Basic tests cover indicator toggle and formatting","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-09T23:00:28.958713-08:00","updated_at":"2025-12-10T06:52:35.776279-08:00"}
{"id":"noface-bms","title":"Implement adaptive concurrency for worker pool","description":"Replace fixed concurrency with adaptive scaling:\n\nConfig:\n  max_concurrent_global = 8\n  max_concurrent_per_repo = 4\n  initial_concurrency = 2\n\nPolicy:\n1. Start with N = 2\n2. If queue backlog grows and success rate is high → increase toward max\n3. If failures/timeouts increase → back off\n\nReference: [[parallel-execution]] design doc","status":"open","priority":2,"issue_type":"feature","created_at":"2025-12-10T12:01:03.88726-08:00","updated_at":"2025-12-10T12:01:03.88726-08:00","labels":["parallelism","workers"],"dependencies":[{"issue_id":"noface-bms","depends_on_id":"noface-1v7","type":"blocks","created_at":"2025-12-10T16:20:26.299061-08:00","created_by":"daemon"}],"comments":[{"id":59,"issue_id":"noface-bms","author":"femtomc","text":"MANIFEST: primary=[src/worker_pool.zig,src/config.zig] read=[src/state.zig,src/loop.zig] forbidden=[]","created_at":"2025-12-11T00:18:48Z"}]}
{"id":"noface-bqz","title":"Attach quality findings to follow-up issues","description":"When quality pass opens follow-up issues, attach:\n- Links to the original issue\n- The quality agent's analysis (e.g., 'didn't handle null case in X')\n\nWhen implementer picks up follow-up issue, include analysis in prompt:\n  'The previous attempt failed because: [list]. Fix these specific problems.'\n\nThis turns quality pass into a teacher, not just a bug generator.\n\nReference: [[multi-pass]] design doc","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-10T12:02:40.050312-08:00","updated_at":"2025-12-10T12:02:40.050312-08:00","labels":["multi-pass","quality"],"comments":[{"id":73,"issue_id":"noface-bqz","author":"femtomc","text":"MANIFEST: primary=[src/core/loop.zig,src/core/prompts.zig,src/core/state.zig] read=[src/core/config.zig] forbidden=[web/]","created_at":"2025-12-11T04:38:21Z"}]}
{"id":"noface-bs5","title":"Show tool parameters in streaming output","description":"When Claude uses tools during implementation, only the tool name is shown (e.g. '[TOOL] Read'). This makes it hard to follow what the agent is doing. Should extract and display key parameters: file_path for Read/Edit, command for Bash, etc.","acceptance_criteria":"Tool output shows contextual info like '[TOOL] Read src/config.zig' or '[TOOL] Bash: zig build test'","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-12-09T23:22:21.074744-08:00","updated_at":"2025-12-09T23:24:42.472851-08:00","closed_at":"2025-12-09T23:24:42.472851-08:00"}
{"id":"noface-bw7","title":"Add human review gate for high-risk paths","description":"Build risk classification with hard human gate for sensitive areas.\n\nHigh-risk triggers:\n- Files/directories: auth/, payments/, secrets/, infra/, prod-config/\n- Labels: security, compliance, breaking-change\n\nFor high-risk changes:\n- noface never auto-merges\n- Opens PR or surfaces diff with 'requires human approval' flag\n- Optionally pre-annotated with AI reviewer's comments\n\nConfig:\n[verification.human_required]\npaths = ['src/auth/', 'src/payments/', 'config/prod/']\nlabels = ['security', 'compliance']\n\nReference: [[verification]] design doc","status":"open","priority":2,"issue_type":"feature","created_at":"2025-12-10T12:04:54.386954-08:00","updated_at":"2025-12-10T12:04:54.386954-08:00","labels":["human-in-loop","verification"]}
{"id":"noface-c3d","title":"Fix BLOCKED_BY_FILE parsing extracting JSON garbage instead of file path","description":"The checkForBlockedSignal function in worker_pool.zig:1049 searches for BLOCKED_BY_FILE: in the raw output buffer, which includes Claude API JSON responses. When Claude outputs text containing this signal, the surrounding JSON structure gets included in the extracted file path.\n\nExample from trace:\n```\n[POOL] Worker 1 reported blocked on src/loop.zig\"}],\"stop_reason\":null...\n```\n\nThe output buffer contains raw streaming JSON like:\n```json\n{\"content\":\"BLOCKED_BY_FILE: src/loop.zig\"}],\"stop_reason\":null...\n```\n\nRoot cause: Substring search finds the signal inside a JSON string value, then extracts everything until newline - including JSON syntax.\n\nImpact: Workers report blocked on invalid file paths, the file is never found as locked, so workers are never properly marked as waiting and cannot be woken up.\n\nFix options:\n1. Parse text content from JSON events first, then search for the signal\n2. Require BLOCKED_BY_FILE: to be at the start of a line\n3. Add JSON-awareness to avoid matching inside quoted strings","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-10T14:17:52.368849-08:00","updated_at":"2025-12-10T16:03:03.177903-08:00","closed_at":"2025-12-10T16:03:03.177903-08:00","comments":[{"id":31,"issue_id":"noface-c3d","author":"femtomc","text":"Additional case discovered: Read tool output contamination\n\nWhen a worker reads source files (e.g., worker_pool.zig itself), the Read tool output contains the prompt template which includes:\n```\n\\\\If blocked by another engineer's file, output: BLOCKED_BY_FILE: \u003cpath\u003e\n```\n\nThe signal detection then matches this template text, extracting garbage like:\n```\n[POOL] Worker 1 reported blocked on \u003cpath/to/file.zig\u003e\\n   399→            \\\\\\\\   - The orchestrator will pause you...\n```\n\nThis means the fix must distinguish between:\n1. JSON API response content (streaming events)\n2. Tool output (Read, Grep, etc.) embedded in the response\n3. Actual agent text output intended as a signal\n\nSuggested approach: Only match BLOCKED_BY_FILE: when it appears as a standalone line in parsed assistant text content, not in any tool results or raw JSON.","created_at":"2025-12-10T22:31:24Z"},{"id":41,"issue_id":"noface-c3d","author":"femtomc","text":"MANIFEST: primary=[src/worker_pool.zig] read=[src/streaming.zig,src/state.zig] forbidden=[src/loop.zig]","created_at":"2025-12-10T23:54:11Z"}]}
{"id":"noface-cb8","title":"Refactor: Extract manifest compliance checking into compliance.zig","description":"## Summary\n\nloop.zig contains ~200 lines of manifest compliance verification logic:\n- captureChangedFilesBaseline() (lines ~1480-1545)\n- verifyManifestCompliance() (lines ~1553-1700)\n- ManifestComplianceResult struct\n- Rollback logic for violations\n- Git diff parsing\n\nThis should be extracted into a compliance.zig module focused on manifest enforcement.\n\n## Current Structure in loop.zig\n\n```zig\nconst ManifestComplianceResult = struct {\n    compliant: bool,\n    unauthorized_files: []const []const u8,\n    forbidden_files_touched: []const []const u8,\n    instrumentation: ?ManifestInstrumentation,\n    // ...\n};\n\nfn captureChangedFilesBaseline(self: *AgentLoop) ![]const []const u8 { ... }\nfn freeBaseline(self: *AgentLoop, baseline: []const []const u8) void { ... }\nfn verifyManifestCompliance(self: *AgentLoop, issue_id: []const u8, baseline: []const []const u8) !ManifestComplianceResult { ... }\nfn rollbackForbiddenFiles(self: *AgentLoop, files: []const []const u8) !void { ... }\nfn logManifestInstrumentation(self: *AgentLoop, compliance: ManifestComplianceResult) void { ... }\n```\n\n## Proposed Module: src/compliance.zig\n\n```zig\n//! Manifest compliance verification.\n//!\n//! Checks that agent file modifications comply with declared manifests.\n//! Provides baseline capture, diff analysis, and rollback capabilities.\n\npub const ComplianceChecker = struct {\n    allocator: std.mem.Allocator,\n    \n    pub fn captureBaseline(self: *ComplianceChecker) !Baseline { ... }\n    pub fn verify(self: *ComplianceChecker, manifest: Manifest, baseline: Baseline) !ComplianceResult { ... }\n    pub fn rollback(self: *ComplianceChecker, files: []const []const u8) !void { ... }\n};\n\npub const Baseline = struct {\n    files: []const []const u8,\n    pub fn deinit(self: *Baseline, allocator: Allocator) void { ... }\n};\n\npub const ComplianceResult = struct {\n    compliant: bool,\n    unauthorized_files: []const []const u8,\n    forbidden_files_touched: []const []const u8,\n    instrumentation: ManifestInstrumentation,\n    \n    pub fn deinit(self: *ComplianceResult, allocator: Allocator) void { ... }\n};\n\npub const ManifestInstrumentation = struct {\n    predicted_files: []const []const u8,\n    actual_files: []const []const u8,\n    \n    pub fn falsePositives(self: ManifestInstrumentation) u32 { ... }\n    pub fn falseNegatives(self: ManifestInstrumentation) u32 { ... }\n    pub fn accuracy(self: ManifestInstrumentation) ?f32 { ... }\n};\n```\n\n## Benefits\n\n1. **Reusable**: Worker pool can use same compliance checking\n2. **Testable**: Unit test compliance logic with mock git state\n3. **Metrics**: Instrumentation data can be persisted/analyzed separately\n4. **Extensible**: Add new compliance rules (e.g., test coverage requirements)\n\n## Related Issue\n\n- noface-ms6 (parallel path bypasses manifest/review) depends on this extraction\n\n## Files to Modify\n\n- src/compliance.zig (new)\n- src/loop.zig (use ComplianceChecker)\n- src/worker_pool.zig (integrate compliance checking)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-10T15:44:23.409388-08:00","updated_at":"2025-12-10T20:49:50.449202-08:00","closed_at":"2025-12-10T20:49:50.449202-08:00","labels":["modularization","refactor"],"dependencies":[{"issue_id":"noface-cb8","depends_on_id":"noface-tp9","type":"blocks","created_at":"2025-12-10T15:46:09.40008-08:00","created_by":"daemon"}],"comments":[{"id":68,"issue_id":"noface-cb8","author":"femtomc","text":"MANIFEST: primary=[src/core/loop.zig,src/core/worker_pool.zig,src/core/state.zig,src/core/compliance.zig] read=[src/core/config.zig] forbidden=[web/]","created_at":"2025-12-11T04:37:55Z"}]}
{"id":"noface-ccs","title":"Add failure_hints config section","description":"Add lightweight rule-based 'lessons' for common failure patterns.\n\nConfig:\n[[failure_hints]]\nlabel = 'migration'\nhint = 'Migration issues often need schema changes first. Check schema files.'\n\n[[failure_hints]]\nlanguage = 'zig'\nerror_pattern = 'error.OutOfMemory'\nhint = 'Consider using an arena allocator for temporary allocations.'\n\nPeriodically review failure logs, add new rules where patterns are obvious.\n\nReference: [[failure-recovery]] design doc","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-10T12:03:51.74688-08:00","updated_at":"2025-12-10T12:03:51.74688-08:00","labels":["config","failure-recovery"]}
{"id":"noface-ckk","title":"Planner triggers on new issues","description":"Run planner immediately when new issues are created or imported so manifests/batches stay fresh. Current event-driven loop only triggers on empty queue/batch completion; new work can sit without manifests. Integrate with enqueue path and persist so restarts still plan queued issues.","design":"multi-pass","acceptance_criteria":"Newly created/imported issue triggers planner without manual interval; planner generates manifest and batch entries for the new issue; no duplicate planner runs when many issues arrive; behavior persists after restart.","status":"open","priority":1,"issue_type":"feature","created_at":"2025-12-10T21:40:32.853707-08:00","updated_at":"2025-12-10T21:40:32.853707-08:00"}
{"id":"noface-cs6","title":"Handle agent-requested context signals (NEED_CODE/NEED_DOC)","description":"Implement context-injection decision #6: detect agent requests for extra context (NEED_CODE/NEED_DOC), fetch the referenced code/doc snippets via retrieval or harness APIs, and re-prompt with the added context while enforcing manifest/lock rules.","design":"context-injection","acceptance_criteria":"• Agent outputs NEED_CODE/NEED_DOC are parsed and recorded during runs.\n• Orchestrator fetches the requested content (or rejects with reason if forbidden/locked) and feeds it into the next prompt/turn.\n• Requests and responses are logged (for observability) and respect manifest + lock constraints.","status":"open","priority":2,"issue_type":"feature","created_at":"2025-12-10T12:19:58.78453-08:00","updated_at":"2025-12-10T12:19:58.78453-08:00"}
{"id":"noface-dc2","title":"Doc agent: Critic agent for ruthless editing","description":"## Phase 3: Critic Agent\n\nIterative refinement loop that cuts fluff and fixes errors.\n\n### Critic Checks\n\n**Filler Detection:**\n- \"just\", \"simply\", \"basically\", \"very\", \"really\"\n- \"It is important to note that...\"\n- \"In order to...\" (just use \"To...\")\n- Redundant adjectives\n\n**Completeness Check:**\n- All parameters documented?\n- Return value described?\n- Error cases mentioned?\n- Example provided?\n\n**Accuracy Check:**\n- Does description match code?\n- Are parameter names correct?\n- Consistent with existing docs?\n\n### Critic Actions\n\n- `DELETE: \u003csentence\u003e` - Remove unnecessary content\n- `REWRITE: \u003coriginal\u003e -\u003e \u003cimproved\u003e` - Tighten prose\n- `ADD: \u003csection\u003e` - Missing required info\n- `FLAG: \u003cconcern\u003e` - Uncertain, needs human review\n\n### Loop Implementation\n\n```\nfor i in range(3):  # Max 3 iterations\n    critique = Critic.review(draft)\n    if critique.approved:\n        break\n    draft = Writer.revise(draft, critique)\n```\n\n### Stopping Conditions\n\n- Critic approves (no more edits)\n- Max iterations reached (escalate to human)\n- No changes between iterations (converged)\n\nSee: [[design/doc-agent]]","status":"open","priority":3,"issue_type":"feature","created_at":"2025-12-10T15:15:03.78195-08:00","updated_at":"2025-12-10T15:15:03.78195-08:00","dependencies":[{"issue_id":"noface-dc2","depends_on_id":"noface-b71","type":"blocks","created_at":"2025-12-10T15:15:47.623588-08:00","created_by":"daemon"}],"comments":[{"id":38,"issue_id":"noface-dc2","author":"femtomc","text":"References: wiki/vault/design/doc-agent.md, wiki/vault/research/technical-writing-agent.md","created_at":"2025-12-10T23:20:09Z"}]}
{"id":"noface-dgt","title":"Parse confidence/risk metadata from agent output","description":"Ask agent to output explicit confidence and risks.\n\nPrompt addition:\n  After implementing, output:\n  CONFIDENCE: X/5\n  RISKS:\n  - [list any edge cases or uncertainties]\n\nPolicy:\n- If confidence ≤ 2/5 → require reviewer + maybe human\n- Also watch for heuristics:\n  - Lots of TODOs in output\n  - 'I think / maybe' in comments\n  - Weirdly small or huge diffs\n\nReference: [[verification]] design doc","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-10T12:04:52.306911-08:00","updated_at":"2025-12-10T12:04:52.306911-08:00","labels":["prompts","verification"]}
{"id":"noface-djm","title":"Implement eager work-stealing across batches for idle workers","description":"Currently executeBatch() in worker_pool.zig:102 blocks until ALL issues in the current batch complete before moving to the next batch. Workers only get assigned issues from the current batch (lines 206-234).\n\nThis causes idle workers when:\n- Batch has fewer issues than workers (e.g., Batch 6 has 2 issues, 3 workers available)\n- A worker completes but other workers are still running on the same batch\n\nExample from trace:\n```\n[POOL] Executing batch 6 with 2 issue(s) using 3 worker(s)\n[POOL] Assigned issue noface-e4p to worker 0\n[POOL] Assigned issue noface-b0h to worker 1\n# Worker 2 sits idle - nothing in Batch 6 to assign\n[POOL] Worker 0 completed issue noface-4h2 in 342s\n# Worker 0 now idle, but Batches 7-12 have work available\n```\n\nProposed fix: When a worker becomes idle and current batch has no unassigned issues:\n1. Check pending_batches for issues that don't conflict with currently-running workers\n2. If non-conflicting issue found, assign it (respecting lock acquisition)\n3. Track which batch each assigned issue came from for proper completion accounting\n\nThis maintains the dependency ordering (batch N issues complete before batch N+1 issues that depend on them) while maximizing worker utilization for independent work.","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-12-10T14:26:23.825148-08:00","updated_at":"2025-12-10T14:29:23.377523-08:00","closed_at":"2025-12-10T14:29:23.377523-08:00"}
{"id":"noface-dxk","title":"Event-driven quality pass triggers","description":"Quality pass should run on signals (batch completion, failure spikes) per [[multi-pass]] design decision #1. Keep interval as fallback but add event-driven triggers: after batch completion, when failure/timeout rate spikes, or when backlog reprioritized. Expose config to select event-driven vs interval.","status":"open","priority":2,"issue_type":"feature","created_at":"2025-12-10T13:39:41.134466-08:00","updated_at":"2025-12-10T13:39:41.134466-08:00","labels":["planner"]}
{"id":"noface-dyf","title":"Event-driven planner instead of interval-based","description":"Currently planner runs every N iterations. Change to event-driven: run planner only when (1) no ready issues, (2) breakdown requested, (3) batch completed and need new batch. Reduces unnecessary planner invocations and token cost.","acceptance_criteria":"Planner runs on-demand not on interval; Triggered by empty queue or batch completion; Config option to choose mode; Token usage reduced","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-10T06:47:04.597739-08:00","updated_at":"2025-12-10T14:38:38.240798-08:00","closed_at":"2025-12-10T14:38:38.240798-08:00","comments":[{"id":8,"issue_id":"noface-dyf","author":"femtomc","text":"MANIFEST: primary=[src/loop.zig,src/config.zig,src/main.zig] read=[README.md] forbidden=[src/web.zig]","created_at":"2025-12-10T17:14:45Z"},{"id":17,"issue_id":"noface-dyf","author":"femtomc","text":"MANIFEST: primary=[src/loop.zig,src/config.zig,src/state.zig] read=[README.md] forbidden=[]","created_at":"2025-12-10T20:40:33Z"},{"id":24,"issue_id":"noface-dyf","author":"femtomc","text":"MANIFEST: primary=[src/loop.zig,src/config.zig,src/main.zig,README.md] read=[src/state.zig,src/worker_pool.zig] forbidden=[]","created_at":"2025-12-10T21:37:12Z"}]}
{"id":"noface-dym","title":"LSP integration for semantic code navigation","description":"Integrate with language servers (zls, rust-analyzer, gopls, etc.) to provide semantic code navigation tools for agents. Spawn LSP as subprocess, communicate via JSON-RPC. Expose tools: goto_definition, find_references, list_symbols, get_callers/callees. Build code graph at startup for fast queries.","acceptance_criteria":"LSP client spawns and initializes language server; goto_definition and find_references work; Code graph cached for call hierarchy queries; Graceful fallback when LSP unavailable","status":"open","priority":2,"issue_type":"feature","created_at":"2025-12-10T07:09:30.867209-08:00","updated_at":"2025-12-10T07:09:30.867209-08:00","dependencies":[{"issue_id":"noface-dym","depends_on_id":"noface-noy","type":"blocks","created_at":"2025-12-10T07:09:40.988372-08:00","created_by":"daemon"}]}
{"id":"noface-e4p","title":"Add --verbose flag for detailed logging","description":"Add a --verbose/-V flag that enables more detailed logging output during execution. When enabled, show:\n- Full commands being executed\n- Timing information for each step\n- Agent prompts being sent (truncated)\n- Raw API responses (summarized)\n\nThis helps with debugging when things go wrong.","acceptance_criteria":"- --verbose/-V flag exists (default off) and parsed via CLI/config\n- Verbose mode prints executed commands, step timings, truncated prompts, summarized API responses\n- Normal mode output remains unchanged/minimal; verbose respects log level for subcomponents\n- Tests cover flag parsing and representative verbose output toggle","status":"in_progress","priority":2,"issue_type":"task","created_at":"2025-12-09T23:00:12.682282-08:00","updated_at":"2025-12-10T13:40:55.666395-08:00","comments":[{"id":3,"issue_id":"noface-e4p","author":"femtomc","text":"MANIFEST: primary=[src/main.zig,src/config.zig,src/loop.zig,src/process.zig] read=[src/worker_pool.zig,README.md] forbidden=[]","created_at":"2025-12-10T17:14:25Z"},{"id":12,"issue_id":"noface-e4p","author":"femtomc","text":"MANIFEST: primary=[src/main.zig,src/config.zig,src/loop.zig,src/process.zig,src/streaming.zig,README.md] read=[src/markdown.zig,src/state.zig] forbidden=[]","created_at":"2025-12-10T20:40:14Z"},{"id":21,"issue_id":"noface-e4p","author":"femtomc","text":"MANIFEST: primary=[src/config.zig,src/main.zig,src/loop.zig,src/process.zig,README.md] read=[src/streaming.zig,src/transcript.zig] forbidden=[]","created_at":"2025-12-10T21:36:56Z"}]}
{"id":"noface-edc","title":"Doc agent: Full pipeline orchestration integration","description":"## Phase 5: Full Pipeline Integration\n\nIntegrate doc agent into noface orchestration loop.\n\n### Pipeline Flow\n\n```\nIssue Complete\n    ↓\nCode Review Pass\n    ↓\nScope Agent: Does this need docs?\n    ↓ (if yes)\nContext Agent: Gather relevant code/docs\n    ↓\nWriter Agent: Generate draft from template\n    ↓\nCritic Loop: Refine (max 3 iterations)\n    ↓\nVerifier: Check accuracy\n    ↓\nOutput: Doc changes\n```\n\n### Trigger Integration\n\nOption A: Run after worker completes, before issue closed\nOption B: Run as separate doc-focused worker\nOption C: Queue doc tasks for batch processing\n\n### Output Options\n\n1. **Inline docstrings**: Add directly to code files\n2. **Separate markdown**: Create/update in `docs/`\n3. **Issue comment**: Attach draft for human review\n4. **PR**: Open separate documentation PR\n\n### Manifest Extension\n\nAdd to issue manifests:\n```\ndocs_scope: api-reference | tutorial | changelog | none\ndocs_files: [\"docs/api.md\", \"README.md\"]\n```\n\n### Human Review Gate\n\n- Always review: New API docs, tutorials\n- Auto-merge: Minor updates, changelog entries\n- Flag for review: Anything critic couldn't resolve\n\n### Dependencies\n\n- noface-ljr (Scope detection)\n- noface-b71 (Writer agent)\n- noface-dc2 (Critic agent)\n- noface-ewy (Verifier agent)\n\nSee: [[design/doc-agent]]","status":"open","priority":3,"issue_type":"feature","created_at":"2025-12-10T15:15:36.396709-08:00","updated_at":"2025-12-10T15:15:36.396709-08:00","dependencies":[{"issue_id":"noface-edc","depends_on_id":"noface-ljr","type":"blocks","created_at":"2025-12-10T15:15:47.422252-08:00","created_by":"daemon"},{"issue_id":"noface-edc","depends_on_id":"noface-b71","type":"blocks","created_at":"2025-12-10T15:15:47.479485-08:00","created_by":"daemon"},{"issue_id":"noface-edc","depends_on_id":"noface-dc2","type":"blocks","created_at":"2025-12-10T15:15:47.531348-08:00","created_by":"daemon"},{"issue_id":"noface-edc","depends_on_id":"noface-ewy","type":"blocks","created_at":"2025-12-10T15:15:47.577401-08:00","created_by":"daemon"}],"comments":[{"id":40,"issue_id":"noface-edc","author":"femtomc","text":"References: wiki/vault/design/doc-agent.md, wiki/vault/research/technical-writing-agent.md","created_at":"2025-12-10T23:20:12Z"}]}
{"id":"noface-eua","title":"Streaming/log parsing duplicated and ad-hoc across paths","description":"We have two unrelated streaming parsers: src/streaming.zig drives sequential runs, while workers parse stdout by substring in src/worker_pool.zig:860-1075 (including BLOCKED_BY_FILE detection). The worker path ignores the shared parser/tool summaries, has no structured event model, and the duplication already caused bugs like garbage BLOCKED_BY_FILE matches. Unify on one streaming/event pipeline that produces structured events (text, tool uses, blocked signals) for both sequential and pool runs, and feed the same events into transcripts/websocket updates so behavior stays consistent.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-10T14:29:00.384383-08:00","updated_at":"2025-12-10T14:29:00.384383-08:00"}
{"id":"noface-ewy","title":"Doc agent: Verifier for factual accuracy","description":"## Phase 4: Verifier Agent\n\nFinal accuracy check against actual code.\n\n### Validation Checks\n\n**Code Examples:**\n- Do examples compile/parse?\n- Do they actually demonstrate the feature?\n- Are imports correct?\n\n**Cross-References:**\n- Do referenced functions exist?\n- Are parameter names correct?\n- Are types accurate?\n- Do links to other docs work?\n\n**Consistency:**\n- Does terminology match codebase?\n- Are naming conventions followed?\n- Does style match existing docs?\n\n### Implementation Options\n\n1. **Static analysis**: Parse code examples, check against AST\n2. **Test execution**: Actually run code examples\n3. **LLM verification**: Second model checks first model's work\n\n### Output\n\n- `VERIFIED` - All checks pass\n- `ERROR: \u003cissue\u003e` - Factual problem found\n- `WARNING: \u003cconcern\u003e` - Possible issue, human review\n\n### Integration\n\nRun after critic loop converges, before outputting final docs.\n\nSee: [[design/doc-agent]]","status":"open","priority":3,"issue_type":"feature","created_at":"2025-12-10T15:15:14.888489-08:00","updated_at":"2025-12-10T15:15:14.888489-08:00","comments":[{"id":39,"issue_id":"noface-ewy","author":"femtomc","text":"References: wiki/vault/design/doc-agent.md, wiki/vault/research/technical-writing-agent.md","created_at":"2025-12-10T23:20:10Z"}]}
{"id":"noface-f77","title":"Worker timeout should track idle output, not wall-clock runtime","description":"agent_timeout_seconds is documented as \"Kill agent if no output for N seconds\" (src/main.zig:108), and streaming runs enforce it based on idle output. In the worker pool path (src/worker_pool.zig:320-360) we instead kill a worker once elapsed wall time exceeds the timeout, even if it is still producing output (e.g., long builds/tests). That causes false positives and interrupts successful work. Track last-output heartbeat from workers (or use a generous wall clock + idle threshold) so only idle workers are terminated, and add coverage around long-running but chatty workers.","status":"in_progress","priority":1,"issue_type":"task","created_at":"2025-12-10T08:58:43.812024-08:00","updated_at":"2025-12-10T12:43:17.812698-08:00","comments":[{"id":2,"issue_id":"noface-f77","author":"femtomc","text":"MANIFEST: primary=[src/worker_pool.zig,src/process.zig] read=[src/config.zig,src/loop.zig] forbidden=[]","created_at":"2025-12-10T17:14:20Z"},{"id":11,"issue_id":"noface-f77","author":"femtomc","text":"MANIFEST: primary=[src/worker_pool.zig] read=[src/process.zig,src/loop.zig,src/main.zig] forbidden=[]","created_at":"2025-12-10T20:40:10Z"}]}
{"id":"noface-fp4","title":"Planner groups issues into parallel batches","description":"Enhance planner to analyze issue manifests and group non-conflicting issues into parallel batches. Issues with disjoint primary_files can run in same batch. Output BATCH blocks with issue lists. Store batches in state.Batch.","acceptance_criteria":"Planner outputs PARALLEL_BATCH sections; Batches stored in orchestrator state; Issues within batch have no file conflicts; Batches respect beads dependency ordering","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-12-10T06:46:13.341275-08:00","updated_at":"2025-12-10T08:17:56.446753-08:00","closed_at":"2025-12-10T08:17:56.446753-08:00","dependencies":[{"issue_id":"noface-fp4","depends_on_id":"noface-gsk","type":"blocks","created_at":"2025-12-10T06:46:26.902582-08:00","created_by":"daemon"}]}
{"id":"noface-grl","title":"Refactor: Extract planner/quality passes from loop.zig into passes.zig","description":"## Summary\n\nloop.zig contains distinct \"pass\" implementations that run periodically or on-demand:\n- Planner pass: Strategic planning, manifest generation, batch creation (~200 lines)\n- Quality pass: Code quality review (~100 lines)\n\nThese should be extracted into a passes.zig module with a common Pass interface.\n\n## Current Structure in loop.zig\n\n```zig\n// Planner pass (lines ~894-1000)\nfn runPlannerPass(self: *AgentLoop) !bool {\n    // Build planner prompt\n    // Run planner agent\n    // Parse manifest comments\n    // Generate batches from manifests\n}\n\n// Quality pass (lines ~1000-1100)\nfn runQualityPass(self: *AgentLoop) !bool {\n    // Build quality prompt\n    // Run quality agent\n    // Parse and store results\n}\n\n// Manifest parsing from planner output\nfn loadManifestsFromComments(self: *AgentLoop) !u32 { ... }\nfn parseManifestLine(line: []const u8) ?Manifest { ... }\nfn generateBatchesFromManifests(self: *AgentLoop) !u32 { ... }\n```\n\n## Proposed Module: src/passes.zig\n\n```zig\n//! Orchestrator passes: planner, quality, and future passes.\n//!\n//! Each pass is a distinct operational mode that can be run\n//! periodically or on-demand.\n\npub const PassContext = struct {\n    allocator: std.mem.Allocator,\n    config: Config,\n    state: *OrchestratorState,\n    prompt_builder: *PromptBuilder,\n};\n\npub const PassResult = struct {\n    success: bool,\n    issues_processed: u32,\n    batches_created: u32,\n    // ... metrics\n};\n\npub fn runPlannerPass(ctx: PassContext) !PassResult { ... }\npub fn runQualityPass(ctx: PassContext) !PassResult { ... }\n\n// Manifest utilities\npub fn loadManifestsFromComments(allocator: Allocator, state: *OrchestratorState) !u32 { ... }\npub fn parseManifestLine(line: []const u8) ?Manifest { ... }\npub fn generateBatchesFromManifests(allocator: Allocator, state: *OrchestratorState) !u32 { ... }\n```\n\n## Benefits\n\n1. **Single Responsibility**: loop.zig focuses on orchestration, not pass implementation\n2. **Extensible**: Easy to add new passes (e.g., refactoring pass, doc sync pass)\n3. **Testable**: Passes can be unit tested with mock state\n4. **Configurable**: Each pass can have its own configuration section\n\n## Dependency\n\n- noface-2d6 (prompts.zig) should be done first so passes use PromptBuilder\n\n## Files to Modify\n\n- src/passes.zig (new)\n- src/loop.zig (extract pass implementations)\n- src/config.zig (add per-pass configuration)","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-10T15:44:05.540517-08:00","updated_at":"2025-12-10T15:44:05.540517-08:00","labels":["modularization","refactor"],"dependencies":[{"issue_id":"noface-grl","depends_on_id":"noface-2d6","type":"blocks","created_at":"2025-12-10T15:46:09.440734-08:00","created_by":"daemon"}]}
{"id":"noface-gsk","title":"Planner generates file manifests for issues","description":"Enhance the planner prompt to analyze each issue and predict which files will be modified. Store manifests in state.IssueState or as beads comments. Manifests include: primary_files (exclusive write), read_files (shared read), forbidden_files (must not touch).","acceptance_criteria":"Planner outputs MANIFEST blocks for issues; Manifests parsed and stored in orchestrator state; bd comments store manifest for persistence across runs","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-12-10T06:45:44.237005-08:00","updated_at":"2025-12-10T07:33:48.733303-08:00","closed_at":"2025-12-10T07:33:48.733303-08:00"}
{"id":"noface-h9g","title":"Parse NEED_CODE signals from agent output","description":"Add structured handling for agent context requests per [[context-injection]] (Agent-Requested Context). Detect lines like 'NEED_CODE: path/to/file' in agent output, fetch the referenced code snippet, and re-prompt with that context (without changing manifest). Log requests and respect manifest/lock constraints.","status":"open","priority":2,"issue_type":"feature","created_at":"2025-12-10T13:39:52.707606-08:00","updated_at":"2025-12-10T13:39:52.707606-08:00","labels":["context"]}
{"id":"noface-hq3","title":"Auto-detect languages and configure LSPs in noface init","description":"Enhance noface init to scan the project for language markers (build.zig, Cargo.toml, package.json, etc.), detect which LSPs are needed, check availability, and configure .noface.toml automatically. Optionally use an initializer agent for complex setups.","acceptance_criteria":"Language detection from file extensions and build files; LSP availability check with install suggestions; Generated .noface.toml includes [lsp] config; Works for mono-repos with multiple languages","status":"open","priority":2,"issue_type":"feature","created_at":"2025-12-10T07:09:30.923312-08:00","updated_at":"2025-12-10T07:09:30.923312-08:00","dependencies":[{"issue_id":"noface-hq3","depends_on_id":"noface-dym","type":"blocks","created_at":"2025-12-10T07:09:41.029-08:00","created_by":"daemon"}]}
{"id":"noface-ibi","title":"Implement scratch branch model for partial progress","description":"Preserve partial progress without exposing half-baked changes to main.\n\nDesign:\n- Each issue has a scratch branch or temp workspace\n- Each attempt commits to that branch\n- If one file fails, you still keep the other 3 as commits in the branch\n- Only when tests + gates pass do you merge that branch to main\n\nThis preserves partial progress for future attempts.\n\nReference: [[failure-recovery]] design doc","status":"open","priority":2,"issue_type":"feature","created_at":"2025-12-10T12:03:42.618275-08:00","updated_at":"2025-12-10T12:03:42.618275-08:00","labels":["failure-recovery","git"]}
{"id":"noface-igq","title":"Add function-level hints to prompt builder","description":"While keeping file-level manifests as the hard safety boundary, add soft function-level hints in the prompt:\n\nExample:\n  You may edit only these functions in foo.zig: [foo, bar].\n\nThis provides guidance without requiring language-aware parsing for enforcement.\n\nReference: [[manifests]] design doc","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-10T12:00:25.16998-08:00","updated_at":"2025-12-10T12:00:25.16998-08:00","labels":["manifests","prompts"]}
{"id":"noface-ius","title":"Add test coverage checking gate","description":"Add test-centric enhancements for changes that add new behavior.\n\nFor changes that add new behavior:\n- Ask agent to write or update tests as part of the task\n- If coverage tool exists, run coverage diff:\n  - If new/changed lines have zero coverage → soft or hard gate\n\nWhere tooling is limited:\n- At least ensure: 'If tests exist in this module, check they were updated'\n- Warn if tests not updated for behavioral changes\n\nReference: [[verification]] design doc","status":"open","priority":3,"issue_type":"feature","created_at":"2025-12-10T12:04:43.301865-08:00","updated_at":"2025-12-10T12:04:43.301865-08:00","labels":["testing","verification"]}
{"id":"noface-j3n","title":"Add freshness tracking to monowiki docs","description":"Track doc freshness to downrank stale docs:\n\nFor each doc, track:\n- last_updated timestamp\n- Optionally 'tied-to-commit' info\n\nHeuristics:\n- If doc references symbols that no longer exist → heavily downrank\n- If now - last_updated \u003e threshold and code changed → downrank\n\nIn prompt, for borderline docs:\n  'Note: this doc may be outdated; prefer current code as source of truth.'\n\nReference: [[context-injection]] design doc","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-10T12:01:50.411444-08:00","updated_at":"2025-12-10T12:01:50.411444-08:00","labels":["context","monowiki"]}
{"id":"noface-jba","title":"Implement multi-process worker pool","description":"Replace sequential agent execution with parallel worker pool. Spawn N worker processes (configurable via num_workers). Each worker runs its own agent session. Coordinator assigns issues from current batch to idle workers. Use state.WorkerState to track lifecycle.","acceptance_criteria":"WorkerPool struct manages N child processes; Workers execute in parallel; Coordinator waits for batch completion before next batch; Worker crashes detected and recovered","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-12-10T06:46:26.958412-08:00","updated_at":"2025-12-10T08:51:57.417587-08:00","closed_at":"2025-12-10T08:51:57.417587-08:00","dependencies":[{"issue_id":"noface-jba","depends_on_id":"noface-fp4","type":"blocks","created_at":"2025-12-10T06:46:41.28963-08:00","created_by":"daemon"},{"issue_id":"noface-jba","depends_on_id":"noface-8fp","type":"blocks","created_at":"2025-12-10T06:46:41.329746-08:00","created_by":"daemon"}]}
{"id":"noface-jvi","title":"Implement self-reflection step for retries","description":"Add optional self-reflection step before retry:\n\n1. Ask model: 'Explain why your last attempt failed and how you will fix it'\n2. Feed that reflection back into the actual implementation prompt\n\nThis helps the model reason about its mistakes before trying again.\n\nReference: [[failure-recovery]] design doc","status":"open","priority":3,"issue_type":"feature","created_at":"2025-12-10T12:03:37.381576-08:00","updated_at":"2025-12-10T12:03:37.381576-08:00","labels":["failure-recovery","prompts"]}
{"id":"noface-jwo","title":"Add retry logic for transient agent failures","description":"When Claude or Codex fails due to transient errors (rate limits, network issues, API errors), retry with exponential backoff instead of failing immediately.\n\nImplementation:\n- Detect retryable errors (429, 5xx, network timeout)\n- Retry up to 3 times with exponential backoff (1s, 2s, 4s)\n- Log retry attempts\n- Only fail after all retries exhausted","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-09T23:00:13.625391-08:00","updated_at":"2025-12-09T23:29:56.158679-08:00","closed_at":"2025-12-09T23:29:56.158679-08:00"}
{"id":"noface-kaq","title":"Add serial lane for hot files","description":"When HotFileStats indicates a file is a bottleneck (high lock_count, long avg_wait), route issues touching that file to a dedicated serial queue.\n\nThis prevents parallelism overhead when a file would serialize anyway.\n\nDepends on HotFileStats tracking being implemented.\n\nReference: [[parallel-execution]] design doc","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-10T12:01:06.314956-08:00","updated_at":"2025-12-10T21:38:06.813163-08:00","closed_at":"2025-12-10T21:38:06.813163-08:00","labels":["locking","parallelism"]}
{"id":"noface-ljr","title":"Doc agent: Scope detection from git diffs","description":"## Phase 1: Scope Detection\n\nDetect when documentation is needed based on code changes.\n\n### Triggers to Detect\n\n- New public function/API added\n- Existing API signature changed  \n- New file in `docs/` or `examples/` directories\n- Issue closed with `docs-needed` label\n- Config options added/changed\n\n### Output Signals\n\n```\nDOC_TASK: api-reference \u003cfunction_name\u003e\nDOC_TASK: tutorial \u003cfeature\u003e\nDOC_TASK: changelog \u003cversion\u003e\nNO_DOCS_NEEDED\n```\n\n### Implementation\n\n1. Parse git diff to identify changed files\n2. For each changed file, analyze:\n   - Is it a public API? (exported, in public module)\n   - Does it have user-facing impact?\n   - Are there existing docs that reference it?\n3. Output doc tasks or NO_DOCS_NEEDED\n\n### Integration Point\n\nRun after code review passes, before issue marked complete.\n\nSee: [[design/doc-agent]]","status":"open","priority":3,"issue_type":"feature","created_at":"2025-12-10T15:14:38.892911-08:00","updated_at":"2025-12-10T15:14:38.892911-08:00","comments":[{"id":36,"issue_id":"noface-ljr","author":"femtomc","text":"References: wiki/vault/design/doc-agent.md, wiki/vault/research/technical-writing-agent.md","created_at":"2025-12-10T23:20:05Z"}]}
{"id":"noface-m77","title":"Improve interrupt handling with graceful shutdown and session persistence","description":"Current interrupt handling (Ctrl+C / SIGTERM) is functional but loses work. Workers are killed immediately and Claude sessions are discarded.\n\n## Current Behavior\n\n1. Signal handler sets atomic `interrupted` flag\n2. Worker pool detects flag in next poll cycle\n3. `killAllWorkers()` sends SIGKILL to all worker processes\n4. Batch reset to `.pending`\n5. State saved, loop exits\n\n## Problems\n\n1. **Sessions lost**: Claude sessions are killed without saving session IDs - no way to resume\n2. **No graceful shutdown**: Workers get SIGKILL, not a chance to clean up\n3. **Partial work lost**: Any uncommitted changes from workers are orphaned\n4. **No progress capture**: If worker was 80% done, that context is lost\n\n## Proposed Improvements\n\n### 1. Capture session IDs before kill\n```\nOn interrupt:\n  for each worker:\n    extract claude_session_id from stream output (if available)\n    store in beads: bd comment \u003cissue\u003e \"Session interrupted. Resume ID: \u003csession_id\u003e\"\n  then kill workers\n```\n\n### 2. Graceful shutdown option\n```\nFirst Ctrl+C:  Set \"shutting_down\" flag, let workers finish current tool call\nSecond Ctrl+C: Force kill all workers (current behavior)\n```\n\n### 3. Store interrupt state in beads\n```\nbd update \u003cissue\u003e --status interrupted\nbd comment \u003cissue\u003e \"Interrupted at: \u003ctimestamp\u003e. Last action: \u003ctool_name\u003e\"\n```\n\n### 4. Resume support\nWhen restarting work on an interrupted issue:\n```\n# Check for saved session\nsession_id = bd comments \u003cissue\u003e | grep \"Resume ID\"\nif session_id:\n    claude --resume \u003csession_id\u003e -p \"You were interrupted. Continue from where you left off.\"\nelse:\n    # Fresh start with context about previous attempt\n    claude -p \"Previous attempt was interrupted. \u003ccontext\u003e\"\n```\n\n## Implementation Notes\n\n- Need to extract session_id from Claude's stream-json output during normal operation (not just at interrupt)\n- Store session_id in WorkerProcess struct as it becomes available\n- Consider adding `interrupted` as a valid IssueStatus in state.zig\n- Double-Ctrl+C pattern is common in CLI tools (docker, npm, etc.)\n\n## Files to Modify\n\n- `src/signals.zig`: Add two-phase interrupt (graceful then force)\n- `src/worker_pool.zig`: Save session IDs before kill, implement graceful shutdown\n- `src/streaming.zig`: Extract session_id from Claude output\n- `src/state.zig`: Add `interrupted` status","status":"open","priority":2,"issue_type":"feature","created_at":"2025-12-10T14:45:42.305267-08:00","updated_at":"2025-12-10T14:45:42.305267-08:00"}
{"id":"noface-ms6","title":"Parallel worker path bypasses manifest/review pipeline","description":"In batch mode we launch raw workers from src/worker_pool.zig:269-315 via {impl_agent} and only look at the exit code collected in collectCompletedWorkers. The single-issue path in src/loop.zig runs manifest compliance (rollback of forbidden files), codex review, build/test verification, progress file/GitHub sync, and richer logging. That whole pipeline is skipped for workers, so parallel runs can ship manifest violations or unreviewed diffs and state stays inconsistent. Refactor to share a common IssueExecutor between sequential and pool execution so both paths enforce manifest checks, review/test gates, and consistent progress/logging, then add tests that batch vs sequential produce the same lifecycle for a mocked issue.","status":"in_progress","priority":1,"issue_type":"bug","created_at":"2025-12-10T14:27:55.829392-08:00","updated_at":"2025-12-10T16:25:13.630012-08:00","comments":[{"id":42,"issue_id":"noface-ms6","author":"femtomc","text":"MANIFEST: primary=[src/worker_pool.zig,src/loop.zig,src/state.zig] read=[src/process.zig,src/config.zig] forbidden=[]","created_at":"2025-12-10T23:54:15Z"},{"id":51,"issue_id":"noface-ms6","author":"femtomc","text":"MANIFEST: primary=[src/worker_pool.zig,src/loop.zig,src/state.zig,src/issue_executor.zig] read=[src/process.zig,src/git.zig,src/config.zig,src/streaming.zig,src/transcript.zig] forbidden=[]","created_at":"2025-12-11T00:18:08Z"}]}
{"id":"noface-n14","title":"Implement failure taxonomy enum","description":"Introduce a failure taxonomy and map each to a strategy:\n\n| Failure Type      | Strategy                                    |\n|-------------------|---------------------------------------------|\n| SYNTAX_ERROR      | Re-prompt with 'fix syntax error'           |\n| RUNTIME_ERROR     | Include stack trace, ask to fix             |\n| TEST_FAILURE      | Include test output, ask to fix             |\n| NO_DIFF           | 'You must change code'                      |\n| TIMEOUT           | Break down task / reduce scope              |\n| MANIFEST_VIOLATION| Replan + retry with expanded manifest       |\n| AGENT_CONFUSION   | Involve planner or human for clarification  |\n\nReference: [[failure-recovery]] design doc","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-10T12:03:46.70808-08:00","updated_at":"2025-12-10T12:03:46.70808-08:00","labels":["failure-recovery"]}
{"id":"noface-n9f","title":"Design structured edit format for AST-aware patching","description":"Design a structured edit format that enables AST-aware merging:\n\nInstead of raw text patches, agents emit:\n- 'Replace function foo body with ...'\n- 'Add new function bar...'\n\nBenefits:\n- Two agents modifying different functions in same file → trivially merge\n- Same function → detected as conflict\n\nThis is a middle ground between text patches and full CRDTs.\n\nReference: [[parallel-execution]] design doc","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-10T12:01:11.085301-08:00","updated_at":"2025-12-10T12:01:11.085301-08:00","labels":["design","merging","parallelism"]}
{"id":"noface-noy","title":"BM25 code search index for token-efficient retrieval","description":"Implement a BM25 lexical search index that agents can use to find relevant code without full file contents in prompts. Index codebase into ~50 line chunks, provide search tool that returns file:line-range references with relevance scores. Dramatically reduces token usage for large codebases.","acceptance_criteria":"Index built at startup from source files; search() returns ranked results with file:line-range; Sub-100ms query latency on typical codebases; Integration test shows token reduction","status":"open","priority":2,"issue_type":"feature","created_at":"2025-12-10T07:09:15.122453-08:00","updated_at":"2025-12-10T07:09:15.122453-08:00","dependencies":[{"issue_id":"noface-noy","depends_on_id":"noface-t95","type":"blocks","created_at":"2025-12-10T07:09:41.067108-08:00","created_by":"daemon"}],"comments":[{"id":49,"issue_id":"noface-noy","author":"femtomc","text":"MANIFEST: primary=[src/bm25.zig,src/loop.zig,src/config.zig,src/main.zig] read=[src/monowiki.zig] forbidden=[]","created_at":"2025-12-10T23:54:41Z"},{"id":55,"issue_id":"noface-noy","author":"femtomc","text":"MANIFEST: primary=[src/bm25.zig,src/loop.zig] read=[src/config.zig,src/root.zig] forbidden=[]","created_at":"2025-12-11T00:18:29Z"},{"id":69,"issue_id":"noface-noy","author":"femtomc","text":"MANIFEST: primary=[src/util/bm25.zig,src/core/loop.zig,src/core/config.zig,src/core/prompts.zig] read=[src/core/worker_pool.zig] forbidden=[web/]","created_at":"2025-12-11T04:38:01Z"}]}
{"id":"noface-ocb","title":"Implement: Declarative worker state machine with generated transitions","description":"## Summary\n\nWorker lifecycle is managed via WorkerState.Status enum (state.zig:219) with transitions scattered across worker_pool.zig. The current approach has several problems:\n- Transitions are implicit in procedural code\n- Easy to forget a case or create invalid transitions\n- Hard to visualize the state machine\n\nImplement a **typestate-inspired** declarative state machine where:\n- Valid transitions are defined in one place\n- Invalid transitions are compile-time errors (where possible) or runtime assertions\n- State diagram can be auto-generated from definition\n\n## Background: Typestate\n\nTypestate (Strom \u0026 Yemini, 1986) encodes object state in the type system:\n```\nFile\u003cClosed\u003e → open() → File\u003cOpen\u003e\nFile\u003cOpen\u003e → read() → File\u003cOpen\u003e\nFile\u003cOpen\u003e → close() → File\u003cClosed\u003e\n```\n\nIn Zig, we can approximate this with:\n- Compile-time state machine definition\n- Generated switch statements\n- Runtime assertions for dynamic transitions\n\n## Current State Machine (Implicit)\n\n```\nStatus = { idle, starting, running, completed, failed, timeout, waiting }\n\nTransitions (scattered across worker_pool.zig):\n  idle → starting       (line 308: assigned issue)\n  starting → running    (line 308: process spawned)\n  running → completed   (line 186: exit code 0)\n  running → failed      (line 186: exit code != 0)\n  running → timeout     (line 560: idle timeout)\n  running → waiting     (line 631: BLOCKED_BY_FILE)\n  waiting → running     (line 669-684: file unlocked, resume)\n  * → idle              (line 583-587: kill/reset)\n```\n\n## Proposed Design\n\n```zig\n// Declarative definition\nconst WorkerStateMachine = StateMachine(WorkerState.Status){\n    .transitions = .{\n        .idle     =\u003e .{ .assign   =\u003e .starting },\n        .starting =\u003e .{ .spawn    =\u003e .running },\n        .running  =\u003e .{ .complete =\u003e .completed,\n                        .fail     =\u003e .failed,\n                        .timeout  =\u003e .timeout,\n                        .block    =\u003e .waiting },\n        .waiting  =\u003e .{ .resume   =\u003e .running },\n        // Terminal states: completed, failed, timeout\n        // Any state can reset to idle via .kill\n    },\n};\n\n// Generated helper\nfn transition(self: *WorkerState, event: Event) !void {\n    const next = WorkerStateMachine.next(self.status, event) orelse \n        return error.InvalidTransition;\n    self.status = next;\n}\n```\n\n## Deliverables\n\n1. **StateMachine comptime utility** in src/state_machine.zig\n   - Generic over state enum\n   - Validates transitions at comptime where possible\n   - Generates transition function\n\n2. **Refactored WorkerState** using the state machine\n   - All transitions go through `transition()` method\n   - Invalid transitions logged/asserted\n\n3. **State diagram generator** (optional, nice-to-have)\n   - Output Mermaid/Graphviz from state machine definition\n   - Add to wiki/vault/design/worker-states.md\n\n4. **Tests** for valid/invalid transitions\n\n## References\n\n- Strom, R. \u0026 Yemini, S. (1986). \"Typestate: A Programming Language Concept for Enhancing Software Reliability\"\n- Rust's typestate pattern: https://cliffle.com/blog/rust-typestate/\n- Aldrich, J. et al. (2009). \"Typestate-Oriented Programming\"\n\n## Files to Create/Modify\n\n- src/state_machine.zig (new)\n- src/state.zig (refactor WorkerState)\n- src/worker_pool.zig (use transition() method)","status":"open","priority":2,"issue_type":"feature","created_at":"2025-12-10T15:38:21.479003-08:00","updated_at":"2025-12-10T15:38:21.479003-08:00","labels":["implementation","pl-foundations"],"dependencies":[{"issue_id":"noface-ocb","depends_on_id":"noface-2ua","type":"blocks","created_at":"2025-12-10T15:40:52.116233-08:00","created_by":"daemon"}]}
{"id":"noface-okq","title":"Abstract model selection behind role config","description":"Abstract model selection behind roles for easy A/B testing:\n\n[models]\nplanner = 'claude'       # strong model for planning\nimplementer = 'claude'   # strong model for implementation\nreviewer = 'claude'      # can use cheaper if cost-sensitive\nquality = 'codex'        # can use cheaper for triage\n\nThis allows experimenting with different model combinations per role.\n\nReference: [[multi-pass]] design doc","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-10T12:02:43.926026-08:00","updated_at":"2025-12-10T12:02:43.926026-08:00","labels":["config","multi-pass"]}
{"id":"noface-oqi","title":"Add built-in GitHub Issues sync when sync_to_github is enabled","description":"Main loop step 6 in the design doc is to sync beads issues to GitHub. Today we just call an optional shell script and otherwise do nothing, so the default sync_to_github=true does not actually mirror status upstream.","design":"README.md \u003e How It Works (step 6)","acceptance_criteria":"- Provide a built-in sync helper that uses gh CLI to create/update/close the corresponding GitHub issue for the current bead when sync_to_github is true (respect dry-run).\\n- Auto-detect target repo from git remotes or config; emit clear warnings and continue if gh is unavailable/misconfigured.\\n- Minimal test or mockable wrapper to exercise sync logic; docs/--help mention expected GitHub setup.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-09T23:18:18.937106-08:00","updated_at":"2025-12-10T06:16:58.593188-08:00","closed_at":"2025-12-10T06:16:58.593188-08:00"}
{"id":"noface-pko","title":"Add breakdown agent with file-split strategy","description":"Implement task breakdown for issues that are too large.\n\nTrigger breakdown when:\n- Issue times out repeatedly\n- Fails after N attempts with 'too big' signature (many files, large diff)\n\nBreakdown agent:\n- Run planner with breakdown prompt to propose sub-issues\n- e.g., 'Update schema in A', 'Update API in B', 'Update tests in C'\n- Turn these into child issues, mark parent as epic\n\nFirst version (simple):\n- Split by file: if manifest has 5 files, create 5 issues, each scoped to one file\n\nReference: [[failure-recovery]] design doc","status":"open","priority":2,"issue_type":"feature","created_at":"2025-12-10T12:03:40.168326-08:00","updated_at":"2025-12-10T12:03:40.168326-08:00","labels":["failure-recovery","planner"]}
{"id":"noface-qn8","title":"Implement manifest v2 expansion on NEED_FILE/NEED_DOC","description":"When agent outputs NEED_FILE/NEED_DOC, orchestrator should negotiate manifest v2: check locks, expand manifest if free, re-prompt agent with new files/docs, or deny if locked. Today we only parse signals; no orchestrator-managed expansion or locking coordination.","design":"manifests","acceptance_criteria":"NEED_FILE/NEED_DOC signals cause orchestrator to attempt manifest expansion with proper locking; agent receives updated manifest+context when expansion succeeds; locked files are rejected with clear message; expansions are logged/persisted per issue.","status":"open","priority":1,"issue_type":"feature","created_at":"2025-12-10T21:40:37.718081-08:00","updated_at":"2025-12-10T21:40:37.718081-08:00","dependencies":[{"issue_id":"noface-qn8","depends_on_id":"noface-ye0","type":"blocks","created_at":"2025-12-10T21:40:43.891038-08:00","created_by":"daemon"}]}
{"id":"noface-rt7","title":"Implement: Unified configuration DSL for manifest/batch/config","description":"## Summary\n\nnoface uses several ad-hoc configuration formats:\n1. **TOML config**: .noface.toml for project settings\n2. **Manifest declarations**: MANIFEST: primary=[...] read=[...] in beads comments\n3. **Batch definitions**: PARALLEL_BATCH: N / ISSUES: ... / REASON: ... in planner output\n\nThese formats are inconsistent, parsed separately, and lack schema validation. Unify them into a coherent configuration DSL with:\n- Consistent syntax\n- Schema-based validation\n- IDE support (syntax highlighting, completion)\n\n## Background: Configuration Languages\n\nModern config approaches:\n- **TOML**: Widely used, good for flat config\n- **CUE**: Schema + data unification, validation\n- **Dhall**: Typed configuration language, programmable\n- **Jsonnet**: JSON + functions + imports\n\nFor internal DSLs:\n- S-expressions: Simple, homoiconic\n- Tagged unions: Type-safe in host language\n\n## Current Formats\n\n### 1. TOML Config (.noface.toml)\n```toml\n[project]\nname = \"noface\"\nbuild = \"zig build\"\n\n[agents]\nnum_workers = 3\ntimeout_seconds = 900\n```\n\n### 2. Manifest Declaration (beads comment)\n```\nMANIFEST: primary=[src/foo.zig,src/bar.zig] read=[src/types.zig] forbidden=[src/main.zig]\n```\n\n### 3. Batch Definition (planner output)\n```\nPARALLEL_BATCH: 1\nISSUES:\n- noface-abc\n- noface-xyz\nREASON: No file conflicts\n```\n\n## Proposed Unified Format\n\nOption A: **Extend TOML** for all config\n\n```toml\n# In beads issue description\n[manifest]\nprimary = [\"src/foo.zig\", \"src/bar.zig\"]\nread = [\"src/types.zig\"]\nforbidden = [\"src/main.zig\"]\n\n# Batch definition\n[[batch]]\nid = 1\nissues = [\"noface-abc\", \"noface-xyz\"]\nreason = \"No file conflicts\"\n```\n\nOption B: **Zig comptime DSL** for type safety\n\n```zig\nconst config = Config{\n    .project = .{ .name = \"noface\", .build = \"zig build\" },\n    .manifest = .{\n        .primary = \u0026.{\"src/foo.zig\"},\n        .read = \u0026.{\"src/types.zig\"},\n    },\n};\n```\n\nOption C: **S-expression DSL** for simplicity\n\n```lisp\n(manifest\n  (primary \"src/foo.zig\" \"src/bar.zig\")\n  (read \"src/types.zig\")\n  (forbidden \"src/main.zig\"))\n\n(batch 1\n  (issues \"noface-abc\" \"noface-xyz\")\n  (reason \"No file conflicts\"))\n```\n\n## Recommendation\n\nUse **extended TOML** (Option A) because:\n- Already used for .noface.toml\n- Familiar syntax\n- Good tooling (syntax highlighting, parsers)\n- Can embed in beads comments as inline TOML blocks\n\n## Deliverables\n\n1. **Schema definition** for unified config\n   - JSON Schema or CUE schema\n   - Covers project, agents, manifests, batches\n\n2. **Unified parser** in src/config.zig\n   - Parse all config types from TOML\n   - Validation against schema\n   - Clear error messages with line numbers\n\n3. **Migration guide** for existing formats\n   - How to convert current manifests\n   - Backward compatibility period\n\n4. **IDE support** (optional)\n   - VS Code extension for .noface.toml\n   - Syntax highlighting for embedded manifests\n\n## References\n\n- TOML: https://toml.io/\n- CUE: https://cuelang.org/\n- Dhall: https://dhall-lang.org/\n- JSON Schema: https://json-schema.org/\n\n## Files to Modify\n\n- src/config.zig (extend parser)\n- src/loop.zig (update manifest parsing)\n- wiki/vault/design/config-schema.md (new schema doc)","status":"closed","priority":3,"issue_type":"feature","created_at":"2025-12-10T15:40:08.174868-08:00","updated_at":"2025-12-10T21:35:51.804611-08:00","closed_at":"2025-12-10T21:35:51.804611-08:00","labels":["implementation","pl-foundations"],"dependencies":[{"issue_id":"noface-rt7","depends_on_id":"noface-2ua","type":"blocks","created_at":"2025-12-10T15:40:52.233712-08:00","created_by":"daemon"},{"issue_id":"noface-rt7","depends_on_id":"noface-0px","type":"blocks","created_at":"2025-12-10T15:40:52.273186-08:00","created_by":"daemon"}]}
{"id":"noface-s3n","title":"File lock acquisition before worker dispatch","description":"Before assigning issue to worker, acquire locks for all primary_files in manifest. Use state.tryAcquireLocks(). If any file locked by another issue, skip and try next issue. Release locks on completion/failure. Clean up stale locks from crashed workers.","acceptance_criteria":"Locks acquired before worker starts; Conflicting issues wait for locks; Locks released on completion; Stale lock cleanup on crash recovery","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-12-10T06:46:41.384087-08:00","updated_at":"2025-12-10T09:01:48.021876-08:00","closed_at":"2025-12-10T09:01:48.021876-08:00","dependencies":[{"issue_id":"noface-s3n","depends_on_id":"noface-jba","type":"blocks","created_at":"2025-12-10T06:46:52.164439-08:00","created_by":"daemon"},{"issue_id":"noface-s3n","depends_on_id":"noface-gsk","type":"blocks","created_at":"2025-12-10T06:52:16.683807-08:00","created_by":"daemon"}]}
{"id":"noface-st2","title":"Add failure context to retry prompts","description":"Make retries informed, not blind.\n\nOn retry, include:\n- Previous attempt's diff\n- Summarized test output / error\n- Instructions:\n  'Your previous attempt failed with: [error]. Fix that specific problem\n   while preserving working parts.'\n\nReference: [[failure-recovery]] design doc","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-10T12:03:34.881471-08:00","updated_at":"2025-12-10T12:03:34.881471-08:00","labels":["failure-recovery","prompts"],"comments":[{"id":74,"issue_id":"noface-st2","author":"femtomc","text":"MANIFEST: primary=[src/core/loop.zig,src/core/state.zig,src/core/prompts.zig] read=[src/core/worker_pool.zig] forbidden=[web/]","created_at":"2025-12-11T04:38:26Z"}]}
{"id":"noface-t95","title":"Minimal context via file references instead of content","description":"Reduce token cost by passing file REFERENCES instead of full content. Orchestrator pre-analyzes relevant code sections. Prompt includes pointers (file:line-range) not content. Agent uses Read tool to fetch what it needs. Trade-off: more tool calls, much smaller prompts.","acceptance_criteria":"Implementation prompts use reference format; Prompt size reduced by 50%+; Agent successfully uses Read tool for content; Token usage measurably decreased","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-10T06:46:52.220243-08:00","updated_at":"2025-12-10T14:26:33.955488-08:00","closed_at":"2025-12-10T14:26:33.955488-08:00","dependencies":[{"issue_id":"noface-t95","depends_on_id":"noface-s3n","type":"blocks","created_at":"2025-12-10T06:47:21.394847-08:00","created_by":"daemon"}],"comments":[{"id":7,"issue_id":"noface-t95","author":"femtomc","text":"MANIFEST: primary=[src/loop.zig,src/bm25.zig] read=[src/process.zig,src/state.zig] forbidden=[src/web.zig]","created_at":"2025-12-10T17:14:42Z"},{"id":16,"issue_id":"noface-t95","author":"femtomc","text":"MANIFEST: primary=[src/loop.zig,src/streaming.zig] read=[src/state.zig,src/monowiki.zig] forbidden=[]","created_at":"2025-12-10T20:40:30Z"},{"id":23,"issue_id":"noface-t95","author":"femtomc","text":"MANIFEST: primary=[src/loop.zig,src/bm25.zig] read=[src/state.zig,src/monowiki.zig,README.md] forbidden=[]","created_at":"2025-12-10T21:37:06Z"}]}
{"id":"noface-tp9","title":"Refactor: Extract git operations into git.zig","description":"## Summary\n\nGit operations are scattered across loop.zig and compliance checking:\n- git diff --name-only (multiple places)\n- git diff --cached\n- git ls-files --others\n- git checkout (for rollback)\n- git status parsing\n\nExtract into a git.zig module that provides a clean interface for git operations.\n\n## Current Usage (scattered)\n\n```zig\n// In captureChangedFilesBaseline (loop.zig)\nvar diff_result = try process.shell(self.allocator, \"git diff --name-only HEAD\");\nvar staged_result = try process.shell(self.allocator, \"git diff --name-only --cached\");\nvar untracked_result = try process.shell(self.allocator, \"git ls-files --others --exclude-standard\");\n\n// In verifyManifestCompliance (loop.zig)\nvar diff_result = try process.shell(self.allocator, \"git diff --name-only HEAD\");\n\n// In rollbackForbiddenFiles (loop.zig)\nconst checkout_cmd = try std.fmt.allocPrint(self.allocator, \"git checkout HEAD -- {s}\", .{file});\n```\n\n## Proposed Module: src/git.zig\n\n```zig\n//! Git repository operations.\n//!\n//! Provides a clean interface for git operations used by the orchestrator.\n\npub const GitRepo = struct {\n    allocator: std.mem.Allocator,\n    \n    /// Get list of modified files (unstaged)\n    pub fn getModifiedFiles(self: *GitRepo) ![]const []const u8 { ... }\n    \n    /// Get list of staged files\n    pub fn getStagedFiles(self: *GitRepo) ![]const []const u8 { ... }\n    \n    /// Get list of untracked files\n    pub fn getUntrackedFiles(self: *GitRepo) ![]const []const u8 { ... }\n    \n    /// Get all changed files (modified + staged + untracked)\n    pub fn getAllChangedFiles(self: *GitRepo) !ChangedFiles { ... }\n    \n    /// Checkout files to HEAD (discard changes)\n    pub fn checkoutHead(self: *GitRepo, files: []const []const u8) !void { ... }\n    \n    /// Check if working directory is clean\n    pub fn isClean(self: *GitRepo) !bool { ... }\n};\n\npub const ChangedFiles = struct {\n    modified: []const []const u8,\n    staged: []const []const u8,\n    untracked: []const []const u8,\n    \n    pub fn all(self: ChangedFiles) []const []const u8 { ... }\n    pub fn deinit(self: *ChangedFiles, allocator: Allocator) void { ... }\n};\n```\n\n## Benefits\n\n1. **Testable**: Can mock GitRepo for unit tests\n2. **Consistent**: All git operations go through same interface\n3. **Error handling**: Centralized error handling for git failures\n4. **Cacheable**: Could cache results within a single operation\n5. **Portable**: Abstracts away shell command details\n\n## Files to Modify\n\n- src/git.zig (new)\n- src/loop.zig (use GitRepo)\n- src/compliance.zig (use GitRepo)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-10T15:45:42.649474-08:00","updated_at":"2025-12-10T18:36:21.497123-08:00","closed_at":"2025-12-10T18:36:21.497123-08:00","labels":["modularization","refactor"],"comments":[{"id":47,"issue_id":"noface-tp9","author":"femtomc","text":"MANIFEST: primary=[src/git.zig,src/loop.zig] read=[src/process.zig,src/state.zig] forbidden=[]","created_at":"2025-12-10T23:54:33Z"}]}
{"id":"noface-ukr","title":"Tracker access is scattered shell+jq pipelines","description":"Core orchestration (e.g., getNextIssue in src/loop.zig:356-414) shells out to 'bd ... | jq ...' strings for every query (ready, blocked, open count, show). There is no tracker abstraction or typed data model, so we repeat brittle pipelines, risk quoting bugs, and make dataflow hard to test/migrate (e.g., switching trackers). Introduce a beads client module that fetches/filters issues via a single JSON parser, surfaces typed structs/errors, and centralizes tracker selection so both CLI and worker paths share the same code.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-10T14:28:44.246892-08:00","updated_at":"2025-12-10T14:28:44.246892-08:00"}
{"id":"noface-v58","title":"Add HotFileStats tracking for lock contention","description":"Track per-file lock statistics to detect hot files:\n\nstruct HotFileStats {\n    lock_count: u32,\n    avg_wait_ms: u64,\n    queue_depth: u32,\n}\n\nUse this when scheduling to:\n- Force hot-file tasks into a serial lane\n- Suggest planner batch related issues touching hot files\n- Spawn meta-issues like 'split main.zig into modules'\n\nReference: [[parallel-execution]] design doc","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-10T12:01:01.497899-08:00","updated_at":"2025-12-10T21:38:06.813595-08:00","closed_at":"2025-12-10T21:38:06.813595-08:00","labels":["locking","parallelism"],"dependencies":[{"issue_id":"noface-v58","depends_on_id":"noface-1v7","type":"blocks","created_at":"2025-12-10T16:20:30.978821-08:00","created_by":"daemon"}],"comments":[{"id":30,"issue_id":"noface-v58","author":"femtomc","text":"MANIFEST: primary=[src/worker_pool.zig,src/state.zig,src/loop.zig] read=[src/process.zig,README.md] forbidden=[]","created_at":"2025-12-10T21:37:44Z"},{"id":58,"issue_id":"noface-v58","author":"femtomc","text":"MANIFEST: primary=[src/state.zig,src/worker_pool.zig] read=[src/loop.zig,src/config.zig] forbidden=[]","created_at":"2025-12-11T00:18:43Z"}]}
{"id":"noface-wcs","title":"Add manifest instrumentation (predicted vs actual files)","description":"Track manifest accuracy by logging:\n- manifest_files_predicted\n- files_actually_touched (from diff)\n\nCompute false positives (predicted but unused) and false negatives (needed but not declared).\n\nReference: [[manifests]] design doc","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-10T12:00:16.43084-08:00","updated_at":"2025-12-10T14:54:03.417512-08:00","closed_at":"2025-12-10T14:54:03.417512-08:00","labels":["instrumentation","manifests"],"comments":[{"id":20,"issue_id":"noface-wcs","author":"femtomc","text":"MANIFEST: primary=[src/loop.zig,src/state.zig] read=[src/worker_pool.zig,README.md] forbidden=[]","created_at":"2025-12-10T20:40:45Z"},{"id":27,"issue_id":"noface-wcs","author":"femtomc","text":"MANIFEST: primary=[src/loop.zig,src/state.zig,src/worker_pool.zig] read=[src/process.zig,README.md] forbidden=[]","created_at":"2025-12-10T21:37:28Z"}]}
{"id":"noface-wfl","title":"Implement Git worktrees for parallel worker isolation","description":"## Summary\n\nReplace file locking with Git worktrees for parallel worker isolation. Each worker gets its own working directory, eliminating file conflicts entirely.\n\n## Current Approach (file locking)\n- Workers share single working directory\n- Manifests declare file ownership\n- `BLOCKED_BY_FILE` signal when conflicts detected\n- Complex lock acquisition/release lifecycle\n- Race conditions possible\n\n## Proposed Approach (worktrees)\n- Each worker gets dedicated worktree: `.noface-worker-{id}/`\n- Workers can't conflict - isolated filesystems\n- No locking needed, no blocked signals for file conflicts\n- Clean merge back to main after completion\n\n## Implementation Plan\n\n### Phase 1: Worktree lifecycle\n- `createWorkerWorktree(worker_id)` - create before spawn\n- `deleteWorkerWorktree(worker_id)` - cleanup after completion\n- Workers spawn with `cwd` set to worktree path\n\n### Phase 2: Shared caches\n- Zig: Global cache (~/.cache/zig) shared automatically\n- Ensure build artifacts don't conflict\n\n### Phase 3: Merge workflow  \n- After worker completes, merge worktree changes to main\n- Handle merge conflicts (queue for retry or human review)\n- Update git.zig with worktree operations\n\n### Phase 4: Cleanup\n- Remove BLOCKED_BY_FILE detection (or repurpose for other conflicts)\n- Remove file lock acquisition code\n- Crash recovery: clean orphaned worktrees on startup\n\n## Benefits\n- Simpler mental model (no locking)\n- No file conflict races\n- Each worker has clean git state\n- Easy rollback (delete worktree)\n- Disk efficient (worktrees share .git objects)\n\n## Risks\n- Merge conflicts at completion time (mitigated by manifests)\n- More disk I/O (worktree creation)\n- Need to handle beads DB access (still shared)\n\n## Files to Modify\n- src/git.zig: Add worktree operations\n- src/worker_pool.zig: Spawn workers in worktrees\n- src/state.zig: Track worktree paths per worker","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-12-10T18:50:34.814851-08:00","updated_at":"2025-12-10T18:55:13.936486-08:00","closed_at":"2025-12-10T18:55:13.936486-08:00","labels":["architecture","worker-pool"]}
{"id":"noface-x3k","title":"Add merge agent fallback after 3-way conflicts","description":"Implement the parallel-execution conflict policy step 3: when 3-way merge fails, spawn a merge agent with both diffs + base to propose a unified patch. Include manifest context, lock checks, and reuse test commands so we can accept the merged output automatically if it passes.","design":"parallel-execution","acceptance_criteria":"• When conflict detection + 3-way merge fail, orchestrator automatically invokes a merge agent with both diffs and base.\n• Merge agent output applies cleanly, respects manifest scope, and runs the configured build/tests before acceptance.\n• On merge-agent failure, system falls back to existing human/escalation path without losing either diff.","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-10T12:19:50.190203-08:00","updated_at":"2025-12-10T20:26:05.482777-08:00","closed_at":"2025-12-10T20:26:05.482777-08:00"}
{"id":"noface-x94","title":"Replace Git with Jujutsu (jj) for VCS operations","description":"## Summary\nReplace all Git operations in the noface orchestrator with Jujutsu (jj) equivalents. jj workspaces are more ergonomic than git worktrees for parallel worker isolation.\n\n## Motivation\n- jj workspaces are cleaner than git worktrees\n- No explicit staging/committing needed (auto-snapshot)\n- Better conflict handling with jj's change model\n- Built-in undo for all operations\n\n## Implementation Plan\n\n### 1. Create jj.zig to replace git.zig\nReplace git operations with jj equivalents:\n- `git worktree add` → `jj workspace add`\n- `git worktree remove` → `jj workspace forget` + rm directory\n- `git diff --name-only` → `jj diff --name-only`\n- `git status --porcelain` → `jj file list --modified`\n- `git add \u0026\u0026 git commit` → `jj commit` (auto-snapshots working copy)\n- `git cherry-pick` → `jj squash` or rebase\n\n### 2. Update worker_pool.zig\n- Replace GitRepo with JjRepo\n- Update worktree management to use jj workspaces\n- Simplify commit/merge workflow\n\n### 3. Update worker prompt\n- Change git commands to jj equivalents in instructions\n\n### 4. Verify beads compatibility\n- Ensure bd sync still works with colocated jj+git repo\n- Test git hooks still fire\n\n## Files to modify\n- src/git.zig → src/jj.zig (new file, then delete git.zig)\n- src/worker_pool.zig\n- src/loop.zig (if it references git)\n\n## Testing\n- Run `jj git init` to enable colocated mode\n- Test workspace creation/cleanup\n- Test worker execution with jj workspaces\n- Verify changes merge correctly back to main","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-10T19:11:35.453823-08:00","updated_at":"2025-12-10T19:21:30.686377-08:00","closed_at":"2025-12-10T19:21:30.686377-08:00","labels":["refactor"]}
{"id":"noface-y93","title":"Write progress file updates when --progress-file is set","description":"--progress-file is parsed and mentioned in prompts, but noface never writes to the progress markdown itself. The design doc expects the flag to update the file so users can track runs automatically.","design":"README.md \u003e CLI Options (Output options)","acceptance_criteria":"- When progress_file is configured, each iteration appends/updates the markdown file with timestamp, issue id, status (completed/blocked), and short summary.\\n- Creates the file if missing; on write failure, log a warning and continue.\\n- Dry-run mode logs intent without writing; basic test covers progress writer logic.","status":"in_progress","priority":2,"issue_type":"task","created_at":"2025-12-09T23:18:14.18455-08:00","updated_at":"2025-12-10T12:43:12.493803-08:00","comments":[{"id":6,"issue_id":"noface-y93","author":"femtomc","text":"MANIFEST: primary=[src/loop.zig] read=[src/main.zig,src/markdown.zig] forbidden=[]","created_at":"2025-12-10T17:14:38Z"},{"id":15,"issue_id":"noface-y93","author":"femtomc","text":"MANIFEST: primary=[src/loop.zig] read=[src/main.zig,src/config.zig] forbidden=[]","created_at":"2025-12-10T20:40:24Z"}]}
{"id":"noface-y9e","title":"Refactor: Replace manual JSON in state.zig with std.json","description":"## Summary\n\nstate.zig contains ~600 lines of manual JSON serialization/parsing:\n- writeJson() builds JSON by string concatenation (lines ~402-586)\n- parseJson() extracts values with custom string searches (lines ~588-800+)\n- Helper functions: appendJsonField, appendJsonStringField, parseJsonInt, parseJsonString, etc.\n\nThis is error-prone, hard to maintain, and doesn't leverage Zig's std.json capabilities.\n\n## Current Problems\n\n1. **Fragile**: Manual string building is prone to escaping bugs, missing commas\n2. **Verbose**: ~600 lines for what std.json does automatically\n3. **Inconsistent**: Some fields use helpers, others inline\n4. **No validation**: Malformed JSON silently produces wrong state\n5. **Hard to extend**: Adding a new field requires changes in 3+ places\n\n## Example of Current Code (writeJson)\n\n```zig\nfn writeJson(self: *OrchestratorState, out: *std.ArrayListUnmanaged(u8)) !void {\n    try out.appendSlice(self.allocator, \"{\\n\");\n    try appendJsonField(self.allocator, out, \"  \\\"state_version\\\"\", self.state_version);\n    try out.appendSlice(self.allocator, \",\\n\");\n    try appendJsonStringField(self.allocator, out, \"  \\\"project_name\\\"\", self.project_name);\n    // ... 180 more lines of this\n}\n```\n\n## Proposed Refactor\n\nUse `std.json.stringify` and `std.json.parseFromSlice`:\n\n```zig\n/// Serializable state for persistence\nconst SerializableState = struct {\n    state_version: u32,\n    project_name: []const u8,\n    last_saved: i64,\n    total_iterations: u32,\n    // ... all persistable fields\n\n    // Nested types also need to be JSON-compatible\n    workers: []const SerializableWorker,\n    issues: []const SerializableIssue,\n    locks: []const SerializableLock,\n};\n\npub fn save(self: *OrchestratorState) !void {\n    const serializable = self.toSerializable();\n    defer serializable.deinit(self.allocator);\n    \n    var file = try std.fs.cwd().createFile(STATE_FILE, .{});\n    defer file.close();\n    \n    try std.json.stringify(serializable, .{ .whitespace = .indent_2 }, file.writer());\n}\n\npub fn load(allocator: Allocator, path: []const u8) !OrchestratorState {\n    const file = try std.fs.cwd().openFile(path, .{});\n    defer file.close();\n    \n    const content = try file.readToEndAlloc(allocator, 10 * 1024 * 1024);\n    defer allocator.free(content);\n    \n    const parsed = try std.json.parseFromSlice(SerializableState, allocator, content, .{});\n    defer parsed.deinit();\n    \n    return OrchestratorState.fromSerializable(allocator, parsed.value);\n}\n```\n\n## Benefits\n\n1. **Correctness**: std.json handles escaping, unicode, edge cases\n2. **Concise**: ~50 lines instead of ~600\n3. **Type-safe**: Compile-time errors for missing fields\n4. **Extensible**: Add field to struct, serialization updates automatically\n5. **Debuggable**: Standard format, easy to inspect with jq\n\n## Migration Strategy\n\n1. Create SerializableState with same JSON schema as current format\n2. Implement toSerializable() and fromSerializable() converters\n3. Write test that roundtrips current state.json\n4. Replace writeJson/parseJson with std.json calls\n5. Remove manual JSON helpers\n\n## Files to Modify\n\n- src/state.zig (major refactor)\n- Add tests for JSON roundtrip","status":"in_progress","priority":1,"issue_type":"task","created_at":"2025-12-10T15:45:18.448225-08:00","updated_at":"2025-12-10T15:59:33.191741-08:00","labels":["modularization","refactor"],"comments":[{"id":46,"issue_id":"noface-y9e","author":"femtomc","text":"MANIFEST: primary=[src/state.zig] read=[src/loop.zig,src/worker_pool.zig] forbidden=[]","created_at":"2025-12-10T23:54:30Z"}]}
{"id":"noface-ye0","title":"Parse NEED_FILE / NEED_DOC signals from agent output","description":"Allow agents to request additional files mid-execution via structured signals:\n- NEED_FILE: src/auth.zig\n- NEED_DOC: design/auth.md\n\nWhen detected:\n1. Check locks (if file is free, acquire lock)\n2. Produce manifest v2 including the new file\n3. Re-prompt agent with expanded manifest and new file content\n4. If locked by another task, tell agent to proceed without or wait\n\nReference: [[manifests]] design doc","status":"open","priority":2,"issue_type":"feature","created_at":"2025-12-10T12:00:21.646989-08:00","updated_at":"2025-12-10T12:00:21.646989-08:00","labels":["context","manifests"],"dependencies":[{"issue_id":"noface-ye0","depends_on_id":"noface-ms6","type":"blocks","created_at":"2025-12-10T16:20:43.281597-08:00","created_by":"daemon"}],"comments":[{"id":29,"issue_id":"noface-ye0","author":"femtomc","text":"MANIFEST: primary=[src/loop.zig,src/worker_pool.zig,src/state.zig,src/streaming.zig] read=[src/process.zig,README.md] forbidden=[]","created_at":"2025-12-10T21:37:39Z"},{"id":57,"issue_id":"noface-ye0","author":"femtomc","text":"MANIFEST: primary=[src/worker_pool.zig,src/loop.zig,src/state.zig,src/streaming.zig] read=[src/config.zig,src/process.zig] forbidden=[]","created_at":"2025-12-11T00:18:37Z"}]}
{"id":"noface-ykf","title":"Implement 3-way merge fallback for conflicts","description":"Define a conflict resolution pipeline:\n\nStep 1: Detect\n- Two diffs touch overlapping hunks, or git apply fails\n\nStep 2: Auto-merge\n- Try 3-way merge (base, A, B)\n- If succeeds cleanly, run tests\n- If tests pass, accept merged result\n\nStep 3: LLM-assisted merge\n- Spawn a 'merge agent' with both diffs + conflicts\n- Ask it to produce a unified patch\n- Run tests again\n\nStep 4: Escalate\n- If merge agent fails or tests still fail\n- Escalate to human with both original diffs + explanation\n\nReference: [[parallel-execution]] design doc","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-10T12:01:09.057614-08:00","updated_at":"2025-12-10T20:26:05.435934-08:00","closed_at":"2025-12-10T20:26:05.435934-08:00","labels":["merging","parallelism"],"comments":[{"id":60,"issue_id":"noface-ykf","author":"femtomc","text":"MANIFEST: primary=[src/worker_pool.zig,src/git.zig,src/loop.zig,src/merge.zig] read=[src/state.zig,src/process.zig] forbidden=[]","created_at":"2025-12-11T00:18:52Z"}]}
{"id":"noface-yrc","title":"Persist manifests and batches across restarts","description":"State persistence in src/state.zig only writes metadata, worker status, bare issue status, and locks; manifests, pending/current batches, and attempt history are dropped. After a crash/restart the orchestrator loses manifest permissions and the parallel execution plan, so crash recovery cannot reconstruct locks or pending work. Serialize/deserialize manifests, batch queue/current batch, and last attempts in state.json and add tests to verify crash recovery preserves them safely.","status":"in_progress","priority":1,"issue_type":"task","created_at":"2025-12-10T08:58:28.153084-08:00","updated_at":"2025-12-10T12:20:45.49019-08:00","comments":[{"id":1,"issue_id":"noface-yrc","author":"femtomc","text":"MANIFEST: primary=[src/state.zig] read=[src/loop.zig] forbidden=[]","created_at":"2025-12-10T17:14:15Z"}]}
{"id":"noface-zdk","title":"Validate config file and warn about issues","description":"Add config validation that warns users about:\n- Unknown keys in .noface.toml (typos)\n- Invalid values (negative intervals, empty commands)\n- Missing required tools before starting\n- Deprecated options\n\nPrint warnings at startup but don't fail unless critical.","acceptance_criteria":"- Startup validation warns on unknown keys with file/line context; typos do not block execution\n- Invalid values (negative intervals, empty commands) are rejected or warned with suggested fix; critical errors fail fast before run\n- Missing required tools/deprecated options are surfaced before planning/dispatch\n- Tests cover representative valid/invalid configs and warning output","status":"in_progress","priority":2,"issue_type":"task","created_at":"2025-12-09T23:00:14.783734-08:00","updated_at":"2025-12-10T12:43:13.12196-08:00","comments":[{"id":4,"issue_id":"noface-zdk","author":"femtomc","text":"MANIFEST: primary=[src/config.zig,src/main.zig] read=[src/loop.zig,README.md] forbidden=[src/web.zig]","created_at":"2025-12-10T17:14:29Z"},{"id":13,"issue_id":"noface-zdk","author":"femtomc","text":"MANIFEST: primary=[src/config.zig,src/main.zig] read=[README.md,src/loop.zig] forbidden=[]","created_at":"2025-12-10T20:40:17Z"}]}
{"id":"noface-zqb","title":"Add per-pass metrics logging","description":"Log per-pass value metrics to make decisions data-driven.\n\nFor each pass type (planner, reviewer, quality), count:\n- How often it changes outcome\n  - Reviewer finds bug → implementation corrected\n  - Quality pass yields issues not caught otherwise\n\nTrack:\n- Average tokens / time per pass\n- Compute: 'Bugs caught per thousand tokens' or 'per minute'\n\nIf reviewer catches issues in 1/50 changes but costs a lot, restrict to riskier paths.\n\nReference: [[multi-pass]] design doc","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-10T12:02:41.784682-08:00","updated_at":"2025-12-10T12:02:41.784682-08:00","labels":["metrics","multi-pass"]}
