<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Failure Recovery — noface</title>
  <meta name="description" content="Failure Recovery">
  <meta name="author" content="noface">
  <meta name="monowiki-base-url" content="/">
  <meta name="monowiki-note-slug" content="failure-recovery">
  
  <link rel="stylesheet" href="/css/reset.css">
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/css/previews.css">
  <link rel="stylesheet" href="/css/graph.css">
  <link rel="stylesheet" href="/css/search.css">

  <!-- Frontend bundle -->
  <script type="module" src="/js/bundle.js"></script>
</head>
<body>
  <header class="header">
    <div class="header-content">
      <nav class="nav">
        <a href="/index.html">home</a>
        
        <a href="https://github.com/femtomc/noface">github</a>
        <button id="search-trigger" class="search-trigger" aria-label="Search">
          <span class="search-trigger-text">search</span>
          <span class="search-trigger-hint">⌘K</span>
        </button>
      </nav>
    </div>
  </header>

  <main>
    <article>
      
      

      
      <p>
        Tags: <code>design</code> <code>failure</code> <code>retry</code> <code>recovery</code> 
      </p>
      

      
        <div id="toc" class="toc-container">
          <nav class="toc-nav"><h3>Contents</h3><ul class="toc-list"><li class="toc-level-1"><a href="#failure-recovery">Failure Recovery</a></li><li class="toc-level-2"><a href="#current-design">Current Design</a></li><li class="toc-level-2"><a href="#relation-to-survey">Relation to Survey</a></li><li class="toc-level-2"><a href="#design-decisions">Design Decisions</a></li><li class="toc-level-3"><a href="#1-retry-strategies-informed-retries-not-blind">1. Retry Strategies: Informed retries, not blind</a></li><li class="toc-level-3"><a href="#2-task-breakdown-minimal-concrete-decomposition">2. Task Breakdown: Minimal, concrete decomposition</a></li><li class="toc-level-3"><a href="#3-partial-progress-keep-on-branch-all-or-nothing-to-main">3. Partial Progress: Keep on branch, all-or-nothing to main</a></li><li class="toc-level-3"><a href="#4-model-escalation-simple-escalation-policy">4. Model Escalation: Simple escalation policy</a></li><li class="toc-level-3"><a href="#5-failure-classification-taxonomy-with-strategy-mapping">5. Failure Classification: Taxonomy with strategy mapping</a></li><li class="toc-level-3"><a href="#6-human-escalation-clear-threshold-summary">6. Human Escalation: Clear threshold + summary</a></li><li class="toc-level-3"><a href="#7-learning-from-failures-lightweight-rule-based-lessons">7. Learning from Failures: Lightweight rule-based lessons</a></li><li class="toc-level-2"><a href="#implementation-notes">Implementation Notes</a></li><li class="toc-level-3"><a href="#todo">TODO</a></li></ul></nav>
        </div>
        

      <div class="page-subheader">
        
          <button id="copy-page-source" class="copy-page-btn" type="button" aria-label="Copy page Markdown">Copy page source</button>
          
        <button id="global-graph-toggle" class="graph-btn" type="button" aria-label="Open graph">Graph</button>
      </div>

      <h1 id="failure-recovery">Failure Recovery<a class="heading-anchor" href="#failure-recovery" aria-label="Link to heading">#</a></h1>
<p>How noface handles agent failures.</p>
<h2 id="current-design">Current Design<a class="heading-anchor" href="#current-design" aria-label="Link to heading">#</a></h2>
<p>noface handles several failure modes:</p>
<ol>
<li><strong>Transient failures</strong> (429, 5xx, network) — retry up to 3x with exponential backoff</li>
<li><strong>Manifest violations</strong> — rollback offending files, retry with stricter prompt</li>
<li><strong>Timeouts</strong> (no output for N seconds) — break down issue into smaller tasks</li>
<li><strong>Crash recovery</strong> — on startup, detect in-progress work from previous run, reset stale locks, restore state</li>
</ol>
<p>Each attempt is recorded in state with outcome (success/failed/timeout/violation).</p>
<h2 id="relation-to-survey">Relation to Survey<a class="heading-anchor" href="#relation-to-survey" aria-label="Link to heading">#</a></h2>
<p>The survey describes several recovery patterns:</p>
<p><strong>Graceful retries:</strong></p>
<blockquote>
<p>"The simplest recovery pattern is retrying the same prompt. Because LLM agents are stochastic, a second attempt might yield a different (possibly correct) result."</p>
</blockquote>
<p><strong>Progressive prompting:</strong></p>
<blockquote>
<p>"If a direct retry doesn't help, the orchestrator should try a modified approach... break the task into smaller sub-tasks and prompt those instead."</p>
</blockquote>
<p><strong>Preserving partial progress:</strong></p>
<blockquote>
<p>"A robust orchestrator will preserve this partial progress so it's not lost."</p>
</blockquote>
<h2 id="design-decisions">Design Decisions<a class="heading-anchor" href="#design-decisions" aria-label="Link to heading">#</a></h2>
<h3 id="1-retry-strategies-informed-retries-not-blind">1. Retry Strategies: Informed retries, not blind<a class="heading-anchor" href="#1-retry-strategies-informed-retries-not-blind" aria-label="Link to heading">#</a></h3>
<p><strong>Decision:</strong> Retries should include failure context and self-reflection.</p>
<p><strong>On retry, include:</strong></p>
<ul>
<li>Previous attempt's diff</li>
<li>Summarized test output / error</li>
<li>Instructions:<div class="code-block">
<div class="code-toolbar"><button class="copy-code-btn" type="button" aria-label="Copy code">Copy</button></div>
<pre style="background-color:#ffffff;">
<span style="color:#323232;">Your previous attempt failed with: [error]. Fix that specific problem
</span><span style="color:#323232;">while preserving working parts.
</span></pre>

</div></li>
</ul>
<p><strong>Optional self-reflection step:</strong></p>
<ul>
<li>Ask model: "Explain why your last attempt failed and how you will fix it"</li>
<li>Feed that back into the actual implementation prompt</li>
</ul>
<h3 id="2-task-breakdown-minimal-concrete-decomposition">2. Task Breakdown: Minimal, concrete decomposition<a class="heading-anchor" href="#2-task-breakdown-minimal-concrete-decomposition" aria-label="Link to heading">#</a></h3>
<p><strong>Decision:</strong> Implement a simple breakdown strategy when issues are too large.</p>
<p><strong>Trigger breakdown when:</strong></p>
<ul>
<li>Issue times out repeatedly, or</li>
<li>Fails after N attempts with "too big" signature (many files, large diff)</li>
</ul>
<p><strong>Breakdown agent:</strong></p>
<ul>
<li>Run planner with a different prompt to propose sub-issues:
<ul>
<li>e.g., "Update schema in A", "Update API in B", "Update tests in C"</li>
</ul>
</li>
<li>Turn these into child issues, mark parent as an "epic"</li>
</ul>
<p><strong>First version (simple):</strong></p>
<ul>
<li>Split by file: if manifest has 5 files, create 5 issues, each scoped to one file</li>
</ul>
<p>Iterate toward more semantic breakdowns later.</p>
<h3 id="3-partial-progress-keep-on-branch-all-or-nothing-to-main">3. Partial Progress: Keep on branch, all-or-nothing to main<a class="heading-anchor" href="#3-partial-progress-keep-on-branch-all-or-nothing-to-main" aria-label="Link to heading">#</a></h3>
<p><strong>Decision:</strong> Preserve partial progress in scratch branches, but merge atomically.</p>
<p><strong>Design:</strong></p>
<ul>
<li>Each issue has a scratch branch or temp workspace</li>
<li>Each attempt commits to that branch</li>
<li>If one file fails, you still keep the other 3 as commits in the branch</li>
<li>Only when tests + gates pass do you merge that branch to main</li>
</ul>
<p>This preserves partial progress for future attempts without exposing half-baked changes to main.</p>
<h3 id="4-model-escalation-simple-escalation-policy">4. Model Escalation: Simple escalation policy<a class="heading-anchor" href="#4-model-escalation-simple-escalation-policy" aria-label="Link to heading">#</a></h3>
<p><strong>Decision:</strong> Define a simple model escalation policy.</p>
<p><strong>For each issue:</strong></p>
<ul>
<li>First 1–2 attempts: <code>default_model</code> (cheaper)</li>
<li>If still failing with "correctable" errors (tests, syntax): escalate to <code>strong_model</code></li>
<li>Cap total attempts across all models</li>
</ul>
<p>Keep configurable so users can opt-out if they only have access to one model.</p>
<div class="code-block">
<div class="code-toolbar"><button class="copy-code-btn" type="button" aria-label="Copy code">Copy</button></div>
<pre style="background-color:#ffffff;">
<span style="color:#323232;">[retry]
</span><span style="color:#323232;">default_model = &quot;claude-sonnet&quot;
</span><span style="color:#323232;">escalation_model = &quot;claude-opus&quot;
</span><span style="color:#323232;">escalate_after_attempts = 2
</span><span style="color:#323232;">max_total_attempts = 5
</span></pre>

</div>
<h3 id="5-failure-classification-taxonomy-with-strategy-mapping">5. Failure Classification: Taxonomy with strategy mapping<a class="heading-anchor" href="#5-failure-classification-taxonomy-with-strategy-mapping" aria-label="Link to heading">#</a></h3>
<p><strong>Decision:</strong> Introduce a failure taxonomy and map each to a strategy.</p>
<p><strong>Taxonomy:</strong></p>
<table><thead><tr><th>Failure Type</th><th>Strategy</th></tr></thead><tbody>
<tr><td><code>SYNTAX_ERROR</code></td><td>Re-prompt with same context + "fix syntax error"</td></tr>
<tr><td><code>RUNTIME_ERROR</code></td><td>Include stack trace, ask to fix</td></tr>
<tr><td><code>TEST_FAILURE</code></td><td>Include test output, ask to fix</td></tr>
<tr><td><code>NO_DIFF</code></td><td>"You must change code; your previous attempt changed nothing"</td></tr>
<tr><td><code>TIMEOUT</code></td><td>Break down task / reduce scope</td></tr>
<tr><td><code>MANIFEST_VIOLATION</code></td><td>Replan + retry with expanded manifest</td></tr>
<tr><td><code>AGENT_CONFUSION</code></td><td>Involve planner or human for clarification</td></tr>
</tbody></table>
<h3 id="6-human-escalation-clear-threshold-summary">6. Human Escalation: Clear threshold + summary<a class="heading-anchor" href="#6-human-escalation-clear-threshold-summary" aria-label="Link to heading">#</a></h3>
<p><strong>Decision:</strong> Define a clear escalation threshold with actionable summary.</p>
<p><strong>After N consecutive failed attempts (e.g., 3) or severe failure type:</strong></p>
<ol>
<li>Mark issue as <code>BLOCKED</code></li>
<li>Post a summary:
<ul>
<li>What was tried</li>
<li>Errors encountered</li>
<li>What the agent thinks is unclear (if any)</li>
</ul>
</li>
<li>Pause automation until human:
<ul>
<li>Adds context</li>
<li>Edits the issue, or</li>
<li>Manually unblocks / retries</li>
</ul>
</li>
</ol>
<h3 id="7-learning-from-failures-lightweight-rule-based-lessons">7. Learning from Failures: Lightweight rule-based lessons<a class="heading-anchor" href="#7-learning-from-failures-lightweight-rule-based-lessons" aria-label="Link to heading">#</a></h3>
<p><strong>Decision:</strong> Start with manual rule-based "lessons", not ML.</p>
<p><strong>Maintain a small config/ruleset:</strong></p>
<div class="code-block">
<div class="code-toolbar"><button class="copy-code-btn" type="button" aria-label="Copy code">Copy</button></div>
<pre style="background-color:#ffffff;">
<span style="color:#323232;">[[failure_hints]]
</span><span style="color:#323232;">label = &quot;migration&quot;
</span><span style="color:#323232;">hint = &quot;Migration issues often need schema changes first. Check schema files.&quot;
</span><span style="color:#323232;">
</span><span style="color:#323232;">[[failure_hints]]
</span><span style="color:#323232;">language = &quot;zig&quot;
</span><span style="color:#323232;">error_pattern = &quot;error.OutOfMemory&quot;
</span><span style="color:#323232;">hint = &quot;Consider using an arena allocator for temporary allocations.&quot;
</span></pre>

</div>
<p>Periodically review failure logs, add new rules where patterns are obvious.</p>
<p>Later: mine logs to auto-discover patterns, but manual rules get 80% of value quickly.</p>
<h2 id="implementation-notes">Implementation Notes<a class="heading-anchor" href="#implementation-notes" aria-label="Link to heading">#</a></h2>
<p>See <code>src/loop.zig:runIteration</code> retry logic and <code>src/state.zig:IssueState</code>.</p>
<h3 id="todo">TODO<a class="heading-anchor" href="#todo" aria-label="Link to heading">#</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
Add failure context to retry prompts</li>
<li><input disabled="" type="checkbox"/>
Implement self-reflection step</li>
<li><input disabled="" type="checkbox"/>
Add breakdown agent with file-split strategy</li>
<li><input disabled="" type="checkbox"/>
Implement scratch branch model for partial progress</li>
<li><input disabled="" type="checkbox"/>
Add model escalation policy</li>
<li><input disabled="" type="checkbox"/>
Implement failure taxonomy enum</li>
<li><input disabled="" type="checkbox"/>
Add <code>BLOCKED</code> status with human escalation summary</li>
<li><input disabled="" type="checkbox"/>
Add <code>failure_hints</code> config section</li>
</ul>


      
      <hr>
      <div id="backlinks">
        <h3>Backlinks</h3>
        <ul class="backlinks-list">
          
          <li><a href="/verification.html">Verification</a></li>
          
          <li><a href="/index.html">noface</a></li>
          
        </ul>
      </div>
      
    </article>

    
    <hr>

    <p>
      <a href="/index.html">← Back to home</a>
    </p>
    
    </article>

  </main>



  <!-- Global Graph Modal -->
  <div class="global-graph-outer" id="global-graph-outer">
    <div class="global-graph-container" id="global-graph-container"></div>
  </div>

  <!-- Search Modal -->
  <div id="search-modal">
    <div class="search-modal-wrapper">
      <div class="search-modal-header">
        <input
          type="text"
          id="search-modal-input"
          class="search-modal-input"
          placeholder="Search documentation..."
          autocomplete="off"
        />
      </div>
      <div class="search-modal-tabs">
        <button class="search-tab active" data-tab="results">Results</button>
        <button class="search-tab" data-tab="graph">Graph</button>
      </div>
      <div class="search-modal-content">
        <div class="search-tab-panel active" id="search-tab-results">
          <div class="search-modal-results" id="search-modal-results"></div>
        </div>
        <div class="search-tab-panel" id="search-tab-graph">
          <div class="search-graph-container" id="search-graph-container"></div>
        </div>
      </div>
      <div class="search-modal-footer">
        <div class="search-hint">
          <span><kbd>↑</kbd><kbd>↓</kbd> Navigate</span>
          <span><kbd>↵</kbd> Select</span>
          <span><kbd>ESC</kbd> Close</span>
        </div>
        <div class="search-count"></div>
      </div>
    </div>
  </div>

  
    <script id="page-source-data" type="application/json">"# Failure Recovery\n\nHow noface handles agent failures.\n\n## Current Design\n\nnoface handles several failure modes:\n\n1. **Transient failures** (429, 5xx, network) — retry up to 3x with exponential backoff\n2. **Manifest violations** — rollback offending files, retry with stricter prompt\n3. **Timeouts** (no output for N seconds) — break down issue into smaller tasks\n4. **Crash recovery** — on startup, detect in-progress work from previous run, reset stale locks, restore state\n\nEach attempt is recorded in state with outcome (success/failed/timeout/violation).\n\n## Relation to Survey\n\nThe survey describes several recovery patterns:\n\n**Graceful retries:**\n\u003e \"The simplest recovery pattern is retrying the same prompt. Because LLM agents are stochastic, a second attempt might yield a different (possibly correct) result.\"\n\n**Progressive prompting:**\n\u003e \"If a direct retry doesn\u0027t help, the orchestrator should try a modified approach... break the task into smaller sub-tasks and prompt those instead.\"\n\n**Preserving partial progress:**\n\u003e \"A robust orchestrator will preserve this partial progress so it\u0027s not lost.\"\n\n## Design Decisions\n\n### 1. Retry Strategies: Informed retries, not blind\n\n**Decision:** Retries should include failure context and self-reflection.\n\n**On retry, include:**\n- Previous attempt\u0027s diff\n- Summarized test output / error\n- Instructions:\n  ```\n  Your previous attempt failed with: [error]. Fix that specific problem\n  while preserving working parts.\n  ```\n\n**Optional self-reflection step:**\n- Ask model: \"Explain why your last attempt failed and how you will fix it\"\n- Feed that back into the actual implementation prompt\n\n### 2. Task Breakdown: Minimal, concrete decomposition\n\n**Decision:** Implement a simple breakdown strategy when issues are too large.\n\n**Trigger breakdown when:**\n- Issue times out repeatedly, or\n- Fails after N attempts with \"too big\" signature (many files, large diff)\n\n**Breakdown agent:**\n- Run planner with a different prompt to propose sub-issues:\n  - e.g., \"Update schema in A\", \"Update API in B\", \"Update tests in C\"\n- Turn these into child issues, mark parent as an \"epic\"\n\n**First version (simple):**\n- Split by file: if manifest has 5 files, create 5 issues, each scoped to one file\n\nIterate toward more semantic breakdowns later.\n\n### 3. Partial Progress: Keep on branch, all-or-nothing to main\n\n**Decision:** Preserve partial progress in scratch branches, but merge atomically.\n\n**Design:**\n- Each issue has a scratch branch or temp workspace\n- Each attempt commits to that branch\n- If one file fails, you still keep the other 3 as commits in the branch\n- Only when tests + gates pass do you merge that branch to main\n\nThis preserves partial progress for future attempts without exposing half-baked changes to main.\n\n### 4. Model Escalation: Simple escalation policy\n\n**Decision:** Define a simple model escalation policy.\n\n**For each issue:**\n- First 1–2 attempts: `default_model` (cheaper)\n- If still failing with \"correctable\" errors (tests, syntax): escalate to `strong_model`\n- Cap total attempts across all models\n\nKeep configurable so users can opt-out if they only have access to one model.\n\n```toml\n[retry]\ndefault_model = \"claude-sonnet\"\nescalation_model = \"claude-opus\"\nescalate_after_attempts = 2\nmax_total_attempts = 5\n```\n\n### 5. Failure Classification: Taxonomy with strategy mapping\n\n**Decision:** Introduce a failure taxonomy and map each to a strategy.\n\n**Taxonomy:**\n| Failure Type | Strategy |\n|--------------|----------|\n| `SYNTAX_ERROR` | Re-prompt with same context + \"fix syntax error\" |\n| `RUNTIME_ERROR` | Include stack trace, ask to fix |\n| `TEST_FAILURE` | Include test output, ask to fix |\n| `NO_DIFF` | \"You must change code; your previous attempt changed nothing\" |\n| `TIMEOUT` | Break down task / reduce scope |\n| `MANIFEST_VIOLATION` | Replan + retry with expanded manifest |\n| `AGENT_CONFUSION` | Involve planner or human for clarification |\n\n### 6. Human Escalation: Clear threshold + summary\n\n**Decision:** Define a clear escalation threshold with actionable summary.\n\n**After N consecutive failed attempts (e.g., 3) or severe failure type:**\n1. Mark issue as `BLOCKED`\n2. Post a summary:\n   - What was tried\n   - Errors encountered\n   - What the agent thinks is unclear (if any)\n3. Pause automation until human:\n   - Adds context\n   - Edits the issue, or\n   - Manually unblocks / retries\n\n### 7. Learning from Failures: Lightweight rule-based lessons\n\n**Decision:** Start with manual rule-based \"lessons\", not ML.\n\n**Maintain a small config/ruleset:**\n```toml\n[[failure_hints]]\nlabel = \"migration\"\nhint = \"Migration issues often need schema changes first. Check schema files.\"\n\n[[failure_hints]]\nlanguage = \"zig\"\nerror_pattern = \"error.OutOfMemory\"\nhint = \"Consider using an arena allocator for temporary allocations.\"\n```\n\nPeriodically review failure logs, add new rules where patterns are obvious.\n\nLater: mine logs to auto-discover patterns, but manual rules get 80% of value quickly.\n\n## Implementation Notes\n\nSee `src/loop.zig:runIteration` retry logic and `src/state.zig:IssueState`.\n\n### TODO\n- [ ] Add failure context to retry prompts\n- [ ] Implement self-reflection step\n- [ ] Add breakdown agent with file-split strategy\n- [ ] Implement scratch branch model for partial progress\n- [ ] Add model escalation policy\n- [ ] Implement failure taxonomy enum\n- [ ] Add `BLOCKED` status with human escalation summary\n- [ ] Add `failure_hints` config section\n"</script>
    

</body>
</html>