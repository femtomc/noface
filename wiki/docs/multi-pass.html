<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Multi-Pass Architecture — noface</title>
  <meta name="description" content="Multi-Pass Architecture">
  <meta name="author" content="noface">
  <meta name="monowiki-base-url" content="/">
  <meta name="monowiki-note-slug" content="multi-pass">
  
  <link rel="stylesheet" href="/css/reset.css">
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/css/previews.css">
  <link rel="stylesheet" href="/css/graph.css">
  <link rel="stylesheet" href="/css/search.css">

  <!-- Frontend bundle -->
  <script type="module" src="/js/bundle.js"></script>
</head>
<body>
  <header class="header">
    <div class="header-content">
      <nav class="nav">
        <a href="/index.html">home</a>
        
        <a href="https://github.com/femtomc/noface">github</a>
        <button id="search-trigger" class="search-trigger" aria-label="Search">
          <span class="search-trigger-text">search</span>
          <span class="search-trigger-hint">⌘K</span>
        </button>
      </nav>
    </div>
  </header>

  <main>
    <article>
      
      

      
      <p>
        Tags: <code>design</code> <code>planner</code> <code>reviewer</code> <code>passes</code> 
      </p>
      

      
        <div id="toc" class="toc-container">
          <nav class="toc-nav"><h3>Contents</h3><ul class="toc-list"><li class="toc-level-1"><a href="#multi-pass-architecture">Multi-Pass Architecture</a></li><li class="toc-level-2"><a href="#current-design">Current Design</a></li><li class="toc-level-2"><a href="#relation-to-survey">Relation to Survey</a></li><li class="toc-level-2"><a href="#design-decisions">Design Decisions</a></li><li class="toc-level-3"><a href="#1-pass-intervals-event-driven-adaptive-not-fixed">1. Pass Intervals: Event-driven + adaptive (not fixed)</a></li><li class="toc-level-3"><a href="#2-reviewer-pass-yes-for-high-risk-changes">2. Reviewer Pass: Yes, for high-risk changes</a></li><li class="toc-level-3"><a href="#3-feedback-loops-quality-findings-feed-back-to-implementer">3. Feedback Loops: Quality findings feed back to implementer</a></li><li class="toc-level-3"><a href="#4-pass-ordering-planner-on-demand-per-issue-not-just-periodic">4. Pass Ordering: Planner on-demand per-issue (not just periodic)</a></li><li class="toc-level-3"><a href="#5-diminishing-returns-data-driven-pass-value-metrics">5. Diminishing Returns: Data-driven pass value metrics</a></li><li class="toc-level-3"><a href="#6-model-selection-abstract-behind-roles-default-to-strong-model">6. Model Selection: Abstract behind roles, default to strong model</a></li><li class="toc-level-2"><a href="#implementation-notes">Implementation Notes</a></li><li class="toc-level-3"><a href="#todo">TODO</a></li></ul></nav>
        </div>
        

      <div class="page-subheader">
        
          <button id="copy-page-source" class="copy-page-btn" type="button" aria-label="Copy page Markdown">Copy page source</button>
          
        <button id="global-graph-toggle" class="graph-btn" type="button" aria-label="Open graph">Graph</button>
      </div>

      <h1 id="multi-pass-architecture">Multi-Pass Architecture<a class="heading-anchor" href="#multi-pass-architecture" aria-label="Link to heading">#</a></h1>
<p>How noface uses multiple agent passes to improve quality.</p>
<h2 id="current-design">Current Design<a class="heading-anchor" href="#current-design" aria-label="Link to heading">#</a></h2>
<p>noface runs three types of passes:</p>
<ol>
<li>
<p><strong>Planner pass</strong> (Codex) — every N iterations</p>
<ul>
<li>Analyzes issue backlog</li>
<li>Generates file manifests for each issue</li>
<li>Groups non-conflicting issues into parallel batches</li>
</ul>
</li>
<li>
<p><strong>Implementation pass</strong> (Claude) — per issue</p>
<ul>
<li>Receives issue + manifest + context</li>
<li>Implements the change, runs tests, commits</li>
</ul>
</li>
<li>
<p><strong>Quality pass</strong> (Codex) — every M iterations</p>
<ul>
<li>Scans codebase for tech debt</li>
<li>Creates new issues for findings</li>
</ul>
</li>
</ol>
<h2 id="relation-to-survey">Relation to Survey<a class="heading-anchor" href="#relation-to-survey" aria-label="Link to heading">#</a></h2>
<p>This follows the <strong>Planner → Implementer</strong> pattern from <a href="/orchestration-survey.html">orchestration-survey</a>:</p>
<blockquote>
<p>"The self-planning study by Jiang et al. (2025) exemplifies this: the LLM generates concise, structured planning steps from the intent, then in the implementation phase it 'generates code step by step, guided by the preceding planning steps'. This two-pass approach yielded significantly higher correctness than a single-pass solution."</p>
</blockquote>
<p>The survey also discusses <strong>Reviewer passes</strong> for catching mistakes. noface's quality pass is similar but focuses on proactive debt detection rather than reviewing specific changes.</p>
<h2 id="design-decisions">Design Decisions<a class="heading-anchor" href="#design-decisions" aria-label="Link to heading">#</a></h2>
<h3 id="1-pass-intervals-event-driven-adaptive-not-fixed">1. Pass Intervals: Event-driven + adaptive (not fixed)<a class="heading-anchor" href="#1-pass-intervals-event-driven-adaptive-not-fixed" aria-label="Link to heading">#</a></h3>
<p><strong>Decision:</strong> Move from fixed intervals to event-driven + adaptive.</p>
<p><strong>Planner:</strong></p>
<ul>
<li>Run on-demand for new issues (always)</li>
<li>Run periodically when:
<ul>
<li>A manifest violation occurs (planner "missed" a file)</li>
<li>Large codebase change merged (e.g., big refactor)</li>
</ul>
</li>
</ul>
<p><strong>Quality:</strong></p>
<ul>
<li>Run when:
<ul>
<li>A batch of N issues is completed</li>
<li>A spike in failures or bug reports is observed</li>
</ul>
</li>
</ul>
<p>Keep <code>planner_interval</code> and <code>quality_interval</code> as fallback periodic jobs, but teach orchestrator to invoke them in response to signals.</p>
<h3 id="2-reviewer-pass-yes-for-high-risk-changes">2. Reviewer Pass: Yes, for high-risk changes<a class="heading-anchor" href="#2-reviewer-pass-yes-for-high-risk-changes" aria-label="Link to heading">#</a></h3>
<p><strong>Decision:</strong> Add a dedicated reviewer pass, but only for certain classes of changes.</p>
<p><strong>Trigger reviewer when:</strong></p>
<ul>
<li>Diff size &gt; threshold</li>
<li>Changed files in <code>security/</code>, <code>auth/</code>, <code>infra/</code>, <code>config/</code></li>
<li>No tests exist or coverage is low</li>
</ul>
<p><strong>For low-risk, tiny changes where tests are strong:</strong></p>
<ul>
<li>Tests + manifest is probably enough; skip reviewer to save cost</li>
</ul>
<h3 id="3-feedback-loops-quality-findings-feed-back-to-implementer">3. Feedback Loops: Quality findings feed back to implementer<a class="heading-anchor" href="#3-feedback-loops-quality-findings-feed-back-to-implementer" aria-label="Link to heading">#</a></h3>
<p><strong>Decision:</strong> Quality findings should feed back directly to next implementation attempt.</p>
<p><strong>Implementation:</strong></p>
<ul>
<li>When quality pass opens "follow-up issues", attach:
<ul>
<li>Links to the original issue</li>
<li>The quality agent's analysis (e.g., "didn't handle null case in X")</li>
</ul>
</li>
<li>When implementer picks up follow-up issue, include analysis in prompt:<div class="code-block">
<div class="code-toolbar"><button class="copy-code-btn" type="button" aria-label="Copy code">Copy</button></div>
<pre style="background-color:#ffffff;">
<span style="color:#323232;">The previous attempt failed because: [list]. Fix these specific problems.
</span></pre>

</div></li>
</ul>
<p>This turns the quality pass into a teacher, not just a bug generator.</p>
<h3 id="4-pass-ordering-planner-on-demand-per-issue-not-just-periodic">4. Pass Ordering: Planner on-demand per-issue (not just periodic)<a class="heading-anchor" href="#4-pass-ordering-planner-on-demand-per-issue-not-just-periodic" aria-label="Link to heading">#</a></h3>
<p><strong>Decision:</strong> Run planner on-demand for manifests, keep periodic for backlog management.</p>
<p><strong>Flow:</strong></p>
<ol>
<li>New issue arrives</li>
<li>Planner runs, generates manifest + hints</li>
<li>Implementation runs</li>
</ol>
<p><strong>Periodic planner still exists for:</strong></p>
<ul>
<li>Rebalancing / reprioritizing backlog</li>
<li>Suggesting new refactor issues</li>
</ul>
<p>Relying only on periodic planner is where "stale manifests" come from.</p>
<h3 id="5-diminishing-returns-data-driven-pass-value-metrics">5. Diminishing Returns: Data-driven pass value metrics<a class="heading-anchor" href="#5-diminishing-returns-data-driven-pass-value-metrics" aria-label="Link to heading">#</a></h3>
<p><strong>Decision:</strong> Log per-pass value metrics and make decisions data-driven.</p>
<p><strong>For each pass type (planner, reviewer, quality), count:</strong></p>
<ul>
<li>How often it changes outcome:
<ul>
<li>Reviewer finds a bug → implementation corrected</li>
<li>Quality pass yields issues not caught otherwise</li>
</ul>
</li>
</ul>
<p><strong>Track:</strong></p>
<ul>
<li>Average tokens / time per pass</li>
<li>Compute: "Bugs caught per thousand tokens" or "per minute"</li>
</ul>
<p>If reviewer catches issues in 1/50 changes but costs a lot, restrict it to riskier paths.</p>
<h3 id="6-model-selection-abstract-behind-roles-default-to-strong-model">6. Model Selection: Abstract behind roles, default to strong model<a class="heading-anchor" href="#6-model-selection-abstract-behind-roles-default-to-strong-model" aria-label="Link to heading">#</a></h3>
<p><strong>Decision:</strong> Short term, keep it simple and unify models where reasoning matters.</p>
<p><strong>Design:</strong></p>
<div class="code-block">
<div class="code-toolbar"><button class="copy-code-btn" type="button" aria-label="Copy code">Copy</button></div>
<pre style="background-color:#ffffff;">
<span style="color:#323232;">[models]
</span><span style="color:#323232;">planner = &quot;claude&quot;       # strong model for planning
</span><span style="color:#323232;">implementer = &quot;claude&quot;   # strong model for implementation
</span><span style="color:#323232;">reviewer = &quot;claude&quot;      # can use cheaper if cost-sensitive
</span><span style="color:#323232;">quality = &quot;codex&quot;        # can use cheaper for triage
</span></pre>

</div>
<p><strong>Rationale:</strong></p>
<ul>
<li>Planner quality matters a lot; using same strong model as implementer often improves plans</li>
<li>Quality/triage can often use cheaper model if cost is a concern</li>
</ul>
<p>Make it easy to A/B test different combinations.</p>
<h2 id="implementation-notes">Implementation Notes<a class="heading-anchor" href="#implementation-notes" aria-label="Link to heading">#</a></h2>
<p>See <code>src/loop.zig:runPlannerPass</code>, <code>runQualityPass</code>, <code>runIteration</code>.</p>
<h3 id="todo">TODO<a class="heading-anchor" href="#todo" aria-label="Link to heading">#</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
Implement on-demand planner trigger for new issues</li>
<li><input disabled="" type="checkbox"/>
Add reviewer pass with risk-based triggering</li>
<li><input disabled="" type="checkbox"/>
Attach quality findings to follow-up issues</li>
<li><input disabled="" type="checkbox"/>
Add per-pass metrics logging</li>
<li><input disabled="" type="checkbox"/>
Abstract model selection behind role config</li>
</ul>


      
      <hr>
      <div id="backlinks">
        <h3>Backlinks</h3>
        <ul class="backlinks-list">
          
          <li><a href="/index.html">noface</a></li>
          
        </ul>
      </div>
      
    </article>

    
    <hr>

    <p>
      <a href="/index.html">← Back to home</a>
    </p>
    
    </article>

  </main>



  <!-- Global Graph Modal -->
  <div class="global-graph-outer" id="global-graph-outer">
    <div class="global-graph-container" id="global-graph-container"></div>
  </div>

  <!-- Search Modal -->
  <div id="search-modal">
    <div class="search-modal-wrapper">
      <div class="search-modal-header">
        <input
          type="text"
          id="search-modal-input"
          class="search-modal-input"
          placeholder="Search documentation..."
          autocomplete="off"
        />
      </div>
      <div class="search-modal-tabs">
        <button class="search-tab active" data-tab="results">Results</button>
        <button class="search-tab" data-tab="graph">Graph</button>
      </div>
      <div class="search-modal-content">
        <div class="search-tab-panel active" id="search-tab-results">
          <div class="search-modal-results" id="search-modal-results"></div>
        </div>
        <div class="search-tab-panel" id="search-tab-graph">
          <div class="search-graph-container" id="search-graph-container"></div>
        </div>
      </div>
      <div class="search-modal-footer">
        <div class="search-hint">
          <span><kbd>↑</kbd><kbd>↓</kbd> Navigate</span>
          <span><kbd>↵</kbd> Select</span>
          <span><kbd>ESC</kbd> Close</span>
        </div>
        <div class="search-count"></div>
      </div>
    </div>
  </div>

  
    <script id="page-source-data" type="application/json">"# Multi-Pass Architecture\n\nHow noface uses multiple agent passes to improve quality.\n\n## Current Design\n\nnoface runs three types of passes:\n\n1. **Planner pass** (Codex) — every N iterations\n   - Analyzes issue backlog\n   - Generates file manifests for each issue\n   - Groups non-conflicting issues into parallel batches\n\n2. **Implementation pass** (Claude) — per issue\n   - Receives issue + manifest + context\n   - Implements the change, runs tests, commits\n\n3. **Quality pass** (Codex) — every M iterations\n   - Scans codebase for tech debt\n   - Creates new issues for findings\n\n## Relation to Survey\n\nThis follows the **Planner → Implementer** pattern from [[orchestration-survey]]:\n\n\u003e \"The self-planning study by Jiang et al. (2025) exemplifies this: the LLM generates concise, structured planning steps from the intent, then in the implementation phase it \u0027generates code step by step, guided by the preceding planning steps\u0027. This two-pass approach yielded significantly higher correctness than a single-pass solution.\"\n\nThe survey also discusses **Reviewer passes** for catching mistakes. noface\u0027s quality pass is similar but focuses on proactive debt detection rather than reviewing specific changes.\n\n## Design Decisions\n\n### 1. Pass Intervals: Event-driven + adaptive (not fixed)\n\n**Decision:** Move from fixed intervals to event-driven + adaptive.\n\n**Planner:**\n- Run on-demand for new issues (always)\n- Run periodically when:\n  - A manifest violation occurs (planner \"missed\" a file)\n  - Large codebase change merged (e.g., big refactor)\n\n**Quality:**\n- Run when:\n  - A batch of N issues is completed\n  - A spike in failures or bug reports is observed\n\nKeep `planner_interval` and `quality_interval` as fallback periodic jobs, but teach orchestrator to invoke them in response to signals.\n\n### 2. Reviewer Pass: Yes, for high-risk changes\n\n**Decision:** Add a dedicated reviewer pass, but only for certain classes of changes.\n\n**Trigger reviewer when:**\n- Diff size \u003e threshold\n- Changed files in `security/`, `auth/`, `infra/`, `config/`\n- No tests exist or coverage is low\n\n**For low-risk, tiny changes where tests are strong:**\n- Tests + manifest is probably enough; skip reviewer to save cost\n\n### 3. Feedback Loops: Quality findings feed back to implementer\n\n**Decision:** Quality findings should feed back directly to next implementation attempt.\n\n**Implementation:**\n- When quality pass opens \"follow-up issues\", attach:\n  - Links to the original issue\n  - The quality agent\u0027s analysis (e.g., \"didn\u0027t handle null case in X\")\n- When implementer picks up follow-up issue, include analysis in prompt:\n  ```\n  The previous attempt failed because: [list]. Fix these specific problems.\n  ```\n\nThis turns the quality pass into a teacher, not just a bug generator.\n\n### 4. Pass Ordering: Planner on-demand per-issue (not just periodic)\n\n**Decision:** Run planner on-demand for manifests, keep periodic for backlog management.\n\n**Flow:**\n1. New issue arrives\n2. Planner runs, generates manifest + hints\n3. Implementation runs\n\n**Periodic planner still exists for:**\n- Rebalancing / reprioritizing backlog\n- Suggesting new refactor issues\n\nRelying only on periodic planner is where \"stale manifests\" come from.\n\n### 5. Diminishing Returns: Data-driven pass value metrics\n\n**Decision:** Log per-pass value metrics and make decisions data-driven.\n\n**For each pass type (planner, reviewer, quality), count:**\n- How often it changes outcome:\n  - Reviewer finds a bug → implementation corrected\n  - Quality pass yields issues not caught otherwise\n\n**Track:**\n- Average tokens / time per pass\n- Compute: \"Bugs caught per thousand tokens\" or \"per minute\"\n\nIf reviewer catches issues in 1/50 changes but costs a lot, restrict it to riskier paths.\n\n### 6. Model Selection: Abstract behind roles, default to strong model\n\n**Decision:** Short term, keep it simple and unify models where reasoning matters.\n\n**Design:**\n```toml\n[models]\nplanner = \"claude\"       # strong model for planning\nimplementer = \"claude\"   # strong model for implementation\nreviewer = \"claude\"      # can use cheaper if cost-sensitive\nquality = \"codex\"        # can use cheaper for triage\n```\n\n**Rationale:**\n- Planner quality matters a lot; using same strong model as implementer often improves plans\n- Quality/triage can often use cheaper model if cost is a concern\n\nMake it easy to A/B test different combinations.\n\n## Implementation Notes\n\nSee `src/loop.zig:runPlannerPass`, `runQualityPass`, `runIteration`.\n\n### TODO\n- [ ] Implement on-demand planner trigger for new issues\n- [ ] Add reviewer pass with risk-based triggering\n- [ ] Attach quality findings to follow-up issues\n- [ ] Add per-pass metrics logging\n- [ ] Abstract model selection behind role config\n"</script>
    

</body>
</html>