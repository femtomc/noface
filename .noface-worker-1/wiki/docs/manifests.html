<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>File Manifests — noface</title>
  <meta name="description" content="File Manifests">
  <meta name="author" content="noface">
  <meta name="monowiki-base-url" content="/">
  <meta name="monowiki-note-slug" content="manifests">
  
  <link rel="stylesheet" href="/css/reset.css">
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/css/previews.css">
  <link rel="stylesheet" href="/css/graph.css">
  <link rel="stylesheet" href="/css/search.css">

  <!-- Frontend bundle -->
  <script type="module" src="/js/bundle.js"></script>
</head>
<body>
  <header class="header">
    <div class="header-content">
      <nav class="nav">
        <a href="/index.html">home</a>
        
        <a href="https://github.com/femtomc/noface">github</a>
        <button id="search-trigger" class="search-trigger" aria-label="Search">
          <span class="search-trigger-text">search</span>
          <span class="search-trigger-hint">⌘K</span>
        </button>
      </nav>
    </div>
  </header>

  <main>
    <article>
      
      

      
      <p>
        Tags: <code>design</code> <code>manifests</code> <code>access-control</code> 
      </p>
      

      
        <div id="toc" class="toc-container">
          <nav class="toc-nav"><h3>Contents</h3><ul class="toc-list"><li class="toc-level-1"><a href="#file-manifests">File Manifests</a></li><li class="toc-level-2"><a href="#current-design">Current Design</a></li><li class="toc-level-2"><a href="#relation-to-survey">Relation to Survey</a></li><li class="toc-level-2"><a href="#design-decisions">Design Decisions</a></li><li class="toc-level-3"><a href="#1-granularity-file-level-with-soft-function-hints">1. Granularity: File-level with soft function hints</a></li><li class="toc-level-3"><a href="#2-manifest-generation-instrumentation-replan-on-miss">2. Manifest Generation: Instrumentation + replan on miss</a></li><li class="toc-level-3"><a href="#3-manifest-violations-never-accept-as-is">3. Manifest Violations: Never accept as-is</a></li><li class="toc-level-3"><a href="#4-dynamic-expansion-yes-via-orchestrator-mediated-manifest-v2">4. Dynamic Expansion: Yes, via orchestrator-mediated &quot;manifest v2&quot;</a></li><li class="toc-level-2"><a href="#implementation-notes">Implementation Notes</a></li><li class="toc-level-3"><a href="#todo">TODO</a></li></ul></nav>
        </div>
        

      <div class="page-subheader">
        
          <button id="copy-page-source" class="copy-page-btn" type="button" aria-label="Copy page Markdown">Copy page source</button>
          
        <button id="global-graph-toggle" class="graph-btn" type="button" aria-label="Open graph">Graph</button>
      </div>

      <h1 id="file-manifests">File Manifests<a class="heading-anchor" href="#file-manifests" aria-label="Link to heading">#</a></h1>
<p>How noface controls what files each agent can touch.</p>
<h2 id="current-design">Current Design<a class="heading-anchor" href="#current-design" aria-label="Link to heading">#</a></h2>
<p>Manifests declare three access levels per issue:</p>
<ul>
<li><strong>PRIMARY_FILES</strong> — exclusive write access (locked during execution)</li>
<li><strong>READ_FILES</strong> — shared read-only access</li>
<li><strong>FORBIDDEN_FILES</strong> — must never be touched</li>
</ul>
<p>The planner generates manifests by analyzing each issue. After an agent completes, noface runs <code>git diff</code> and verifies compliance. Violations trigger rollback of offending files and retry with a stricter prompt.</p>
<h2 id="relation-to-survey">Relation to Survey<a class="heading-anchor" href="#relation-to-survey" aria-label="Link to heading">#</a></h2>
<p>This implements the <strong>Manifest-Driven AI Development (MAID)</strong> pattern from <a href="/orchestration-survey.html">orchestration-survey</a>:</p>
<blockquote>
<p>"A recent methodology called Manifest-Driven AI Development (MAID) takes this further by treating the manifest as an enforceable contract: after generation, a validator checks that only the declared files/functions were altered and no undeclared edits occurred."</p>
</blockquote>
<h2 id="design-decisions">Design Decisions<a class="heading-anchor" href="#design-decisions" aria-label="Link to heading">#</a></h2>
<h3 id="1-granularity-file-level-with-soft-function-hints">1. Granularity: File-level with soft function hints<a class="heading-anchor" href="#1-granularity-file-level-with-soft-function-hints" aria-label="Link to heading">#</a></h3>
<p><strong>Decision:</strong> Stick to file-level manifests as the hard safety boundary. Add soft function-level hints inside the prompt.</p>
<ul>
<li>Use the manifest as: "these are the only files you're allowed to change"</li>
<li>Inside each file, include function-level "edit targets" in the prompt:<div class="code-block">
<div class="code-toolbar"><button class="copy-code-btn" type="button" aria-label="Copy code">Copy</button></div>
<pre style="background-color:#ffffff;">
<span style="color:#323232;">You may edit only these functions in foo.zig: [foo, bar].
</span></pre>

</div></li>
<li>Line-ranges are brittle (they drift with edits and refactors)</li>
<li>Function-level locking requires language-aware parsing and a robust symbol table — nice-to-have for later, not v1 safety</li>
</ul>
<h3 id="2-manifest-generation-instrumentation-replan-on-miss">2. Manifest Generation: Instrumentation + replan on miss<a class="heading-anchor" href="#2-manifest-generation-instrumentation-replan-on-miss" aria-label="Link to heading">#</a></h3>
<p><strong>Decision:</strong> Treat false negatives as an instrumentation problem first.</p>
<p>Log for each issue:</p>
<ul>
<li><code>manifest_files_predicted</code></li>
<li><code>files_actually_touched</code> (from diff)</li>
</ul>
<p>Compute:</p>
<ul>
<li><strong>False positives:</strong> predicted but unused (acceptable — widens safety sandbox)</li>
<li><strong>False negatives:</strong> needed but not declared (problematic)</li>
</ul>
<p><strong>Short-term behavior:</strong> If the agent attempts to touch a non-manifest file:</p>
<ol>
<li>Reject that attempt</li>
<li>Spawn a replan: run planner again with the new file explicitly mentioned
<ul>
<li>e.g. "You also needed X.zig; update your manifest"</li>
</ul>
</li>
</ol>
<p><strong>Goal:</strong> Tune planner + retrieval so false negatives are rare.</p>
<h3 id="3-manifest-violations-never-accept-as-is">3. Manifest Violations: Never accept as-is<a class="heading-anchor" href="#3-manifest-violations-never-accept-as-is" aria-label="Link to heading">#</a></h3>
<p><strong>Decision:</strong> Never accept a violation directly. Use violations as hints for replanning.</p>
<p>If the change is clearly correct:</p>
<ol>
<li>Record: "Agent wanted to touch foo.zig too"</li>
<li>Re-run planner with that fact, generate a new manifest including foo.zig</li>
<li>Re-run the implementation under the new manifest</li>
<li>Only then accept</li>
</ol>
<p>For interactive mode, offer:</p>
<div class="code-block">
<div class="code-toolbar"><button class="copy-code-btn" type="button" aria-label="Copy code">Copy</button></div>
<pre style="background-color:#ffffff;">
<span style="color:#323232;">Agent touched out-of-manifest file X, the change looks good.
</span><span style="color:#323232;">➜ [Accept &amp; expand manifest] / [Re-run] / [Discard]
</span></pre>

</div>
<p>The automation path should always have a manifest-consistent attempt before merging.</p>
<h3 id="4-dynamic-expansion-yes-via-orchestrator-mediated-manifest-v2">4. Dynamic Expansion: Yes, via orchestrator-mediated "manifest v2"<a class="heading-anchor" href="#4-dynamic-expansion-yes-via-orchestrator-mediated-manifest-v2" aria-label="Link to heading">#</a></h3>
<p><strong>Decision:</strong> Allow agents to request additional files mid-run, but only through explicit orchestrator coordination with locking rules applied.</p>
<p><strong>Flow:</strong></p>
<ol>
<li>Agent hits missing symbol/doc and outputs:<div class="code-block">
<div class="code-toolbar"><button class="copy-code-btn" type="button" aria-label="Copy code">Copy</button></div>
<pre style="background-color:#ffffff;">
<span style="color:#323232;">NEED_FILE: src/auth.zig
</span></pre>

</div>or<div class="code-block">
<div class="code-toolbar"><button class="copy-code-btn" type="button" aria-label="Copy code">Copy</button></div>
<pre style="background-color:#ffffff;">
<span style="color:#323232;">NEED_DOC: design/auth.md
</span></pre>

</div></li>
<li>Orchestrator checks locks:
<ul>
<li>If <code>auth.zig</code> is free:
<ul>
<li>Acquire lock</li>
<li>Produce manifest v2 including <code>auth.zig</code></li>
<li>Re-prompt the agent with expanded manifest and new file content</li>
</ul>
</li>
<li>If locked by another task:
<ul>
<li>Tell agent: "You cannot access auth.zig because it's locked; proceed without or wait"</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>This preserves the isolation model:</p>
<ul>
<li>No silent expansion</li>
<li>All expansions are explicit, logged, and coordinated with concurrency control</li>
</ul>
<h2 id="implementation-notes">Implementation Notes<a class="heading-anchor" href="#implementation-notes" aria-label="Link to heading">#</a></h2>
<p>See <code>src/state.zig:Manifest</code> and <code>src/loop.zig:verifyManifestCompliance</code>.</p>
<h3 id="todo">TODO<a class="heading-anchor" href="#todo" aria-label="Link to heading">#</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
Add manifest instrumentation (predicted vs actual files)</li>
<li><input disabled="" type="checkbox"/>
Implement replan-on-violation flow</li>
<li><input disabled="" type="checkbox"/>
Add <code>NEED_FILE</code> / <code>NEED_DOC</code> signal parsing</li>
<li><input disabled="" type="checkbox"/>
Add function-level hints to prompt builder</li>
</ul>


      
      <hr>
      <div id="backlinks">
        <h3>Backlinks</h3>
        <ul class="backlinks-list">
          
          <li><a href="/index.html">noface</a></li>
          
        </ul>
      </div>
      
    </article>

    
    <hr>

    <p>
      <a href="/index.html">← Back to home</a>
    </p>
    
    </article>

  </main>



  <!-- Global Graph Modal -->
  <div class="global-graph-outer" id="global-graph-outer">
    <div class="global-graph-container" id="global-graph-container"></div>
  </div>

  <!-- Search Modal -->
  <div id="search-modal">
    <div class="search-modal-wrapper">
      <div class="search-modal-header">
        <input
          type="text"
          id="search-modal-input"
          class="search-modal-input"
          placeholder="Search documentation..."
          autocomplete="off"
        />
      </div>
      <div class="search-modal-tabs">
        <button class="search-tab active" data-tab="results">Results</button>
        <button class="search-tab" data-tab="graph">Graph</button>
      </div>
      <div class="search-modal-content">
        <div class="search-tab-panel active" id="search-tab-results">
          <div class="search-modal-results" id="search-modal-results"></div>
        </div>
        <div class="search-tab-panel" id="search-tab-graph">
          <div class="search-graph-container" id="search-graph-container"></div>
        </div>
      </div>
      <div class="search-modal-footer">
        <div class="search-hint">
          <span><kbd>↑</kbd><kbd>↓</kbd> Navigate</span>
          <span><kbd>↵</kbd> Select</span>
          <span><kbd>ESC</kbd> Close</span>
        </div>
        <div class="search-count"></div>
      </div>
    </div>
  </div>

  
    <script id="page-source-data" type="application/json">"# File Manifests\n\nHow noface controls what files each agent can touch.\n\n## Current Design\n\nManifests declare three access levels per issue:\n\n- **PRIMARY_FILES** — exclusive write access (locked during execution)\n- **READ_FILES** — shared read-only access\n- **FORBIDDEN_FILES** — must never be touched\n\nThe planner generates manifests by analyzing each issue. After an agent completes, noface runs `git diff` and verifies compliance. Violations trigger rollback of offending files and retry with a stricter prompt.\n\n## Relation to Survey\n\nThis implements the **Manifest-Driven AI Development (MAID)** pattern from [[orchestration-survey]]:\n\n\u003e \"A recent methodology called Manifest-Driven AI Development (MAID) takes this further by treating the manifest as an enforceable contract: after generation, a validator checks that only the declared files/functions were altered and no undeclared edits occurred.\"\n\n## Design Decisions\n\n### 1. Granularity: File-level with soft function hints\n\n**Decision:** Stick to file-level manifests as the hard safety boundary. Add soft function-level hints inside the prompt.\n\n- Use the manifest as: \"these are the only files you\u0027re allowed to change\"\n- Inside each file, include function-level \"edit targets\" in the prompt:\n  ```\n  You may edit only these functions in foo.zig: [foo, bar].\n  ```\n- Line-ranges are brittle (they drift with edits and refactors)\n- Function-level locking requires language-aware parsing and a robust symbol table — nice-to-have for later, not v1 safety\n\n### 2. Manifest Generation: Instrumentation + replan on miss\n\n**Decision:** Treat false negatives as an instrumentation problem first.\n\nLog for each issue:\n- `manifest_files_predicted`\n- `files_actually_touched` (from diff)\n\nCompute:\n- **False positives:** predicted but unused (acceptable — widens safety sandbox)\n- **False negatives:** needed but not declared (problematic)\n\n**Short-term behavior:** If the agent attempts to touch a non-manifest file:\n1. Reject that attempt\n2. Spawn a replan: run planner again with the new file explicitly mentioned\n   - e.g. \"You also needed X.zig; update your manifest\"\n\n**Goal:** Tune planner + retrieval so false negatives are rare.\n\n### 3. Manifest Violations: Never accept as-is\n\n**Decision:** Never accept a violation directly. Use violations as hints for replanning.\n\nIf the change is clearly correct:\n1. Record: \"Agent wanted to touch foo.zig too\"\n2. Re-run planner with that fact, generate a new manifest including foo.zig\n3. Re-run the implementation under the new manifest\n4. Only then accept\n\nFor interactive mode, offer:\n```\nAgent touched out-of-manifest file X, the change looks good.\n➜ [Accept \u0026 expand manifest] / [Re-run] / [Discard]\n```\n\nThe automation path should always have a manifest-consistent attempt before merging.\n\n### 4. Dynamic Expansion: Yes, via orchestrator-mediated \"manifest v2\"\n\n**Decision:** Allow agents to request additional files mid-run, but only through explicit orchestrator coordination with locking rules applied.\n\n**Flow:**\n1. Agent hits missing symbol/doc and outputs:\n   ```\n   NEED_FILE: src/auth.zig\n   ```\n   or\n   ```\n   NEED_DOC: design/auth.md\n   ```\n2. Orchestrator checks locks:\n   - If `auth.zig` is free:\n     - Acquire lock\n     - Produce manifest v2 including `auth.zig`\n     - Re-prompt the agent with expanded manifest and new file content\n   - If locked by another task:\n     - Tell agent: \"You cannot access auth.zig because it\u0027s locked; proceed without or wait\"\n\nThis preserves the isolation model:\n- No silent expansion\n- All expansions are explicit, logged, and coordinated with concurrency control\n\n## Implementation Notes\n\nSee `src/state.zig:Manifest` and `src/loop.zig:verifyManifestCompliance`.\n\n### TODO\n- [ ] Add manifest instrumentation (predicted vs actual files)\n- [ ] Implement replan-on-violation flow\n- [ ] Add `NEED_FILE` / `NEED_DOC` signal parsing\n- [ ] Add function-level hints to prompt builder\n"</script>
    

</body>
</html>